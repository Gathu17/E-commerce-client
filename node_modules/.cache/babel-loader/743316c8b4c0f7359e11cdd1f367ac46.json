{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { instanceOf } from '../jsutils/instanceOf.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { toObjMap } from '../jsutils/toObjMap.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { getNamedType, isInputObjectType, isInterfaceType, isObjectType, isUnionType } from './definition.mjs';\nimport { isDirective, specifiedDirectives } from './directives.mjs';\nimport { __Schema } from './introspection.mjs';\n/**\n * Test if the given value is a GraphQL schema.\n */\n\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\nexport function assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(\"Expected \".concat(inspect(schema), \" to be a GraphQL schema.\"));\n  }\n\n  return schema;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   query: MyAppQueryRootType,\n *   mutation: MyAppMutationRootType,\n * })\n * ```\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n * ```ts\n * const characterInterface = new GraphQLInterfaceType({\n *   name: 'Character',\n *   ...\n * });\n *\n * const humanType = new GraphQLObjectType({\n *   name: 'Human',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const droidType = new GraphQLObjectType({\n *   name: 'Droid',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const schema = new GraphQLSchema({\n *   query: new GraphQLObjectType({\n *     name: 'Query',\n *     fields: {\n *       hero: { type: characterInterface, ... },\n *     }\n *   }),\n *   ...\n *   // Since this schema references only the `Character` interface it's\n *   // necessary to explicitly list the types that implement it if\n *   // you want them to be included in the final schema.\n *   types: [humanType, droidType],\n * })\n * ```\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. `@include` and\n * `@skip`) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   ...\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\n * })\n * ```\n */\n\nexport var GraphQLSchema = /*#__PURE__*/function (_Symbol$toStringTag) {\n  // Used as a cache for validateSchema().\n  function GraphQLSchema(config) {\n    _classCallCheck(this, GraphQLSchema);\n\n    var _config$extensionASTN, _config$directives; // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n\n\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\n\n    isObjectLike(config) || devAssert(false, 'Must provide configuration object.');\n    !config.types || Array.isArray(config.types) || devAssert(false, \"\\\"types\\\" must be Array if provided but got: \".concat(inspect(config.types), \".\"));\n    !config.directives || Array.isArray(config.directives) || devAssert(false, '\"directives\" must be Array if provided but got: ' + \"\".concat(inspect(config.directives), \".\"));\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n\n    var allReferencedTypes = new Set(config.types);\n\n    if (config.types != null) {\n      var _iterator = _createForOfIteratorHelper(config.types),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var type = _step.value;\n          // When we ready to process this type, we remove it from \"collected\" types\n          // and then add it together with all dependent types in the correct position.\n          allReferencedTypes.delete(type);\n          collectReferencedTypes(type, allReferencedTypes);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n\n    var _iterator2 = _createForOfIteratorHelper(this._directives),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var directive = _step2.value;\n\n        // Directives are not validated until validateSchema() is called.\n        if (isDirective(directive)) {\n          var _iterator4 = _createForOfIteratorHelper(directive.args),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var arg = _step4.value;\n              collectReferencedTypes(arg.type, allReferencedTypes);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    collectReferencedTypes(__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = Object.create(null);\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementationsMap = Object.create(null);\n\n    var _iterator3 = _createForOfIteratorHelper(allReferencedTypes),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var namedType = _step3.value;\n\n        if (namedType == null) {\n          continue;\n        }\n\n        var typeName = namedType.name;\n        typeName || devAssert(false, 'One of the provided types for building the Schema is missing a name.');\n\n        if (this._typeMap[typeName] !== undefined) {\n          throw new Error(\"Schema must contain uniquely named types but contains multiple types named \\\"\".concat(typeName, \"\\\".\"));\n        }\n\n        this._typeMap[typeName] = namedType;\n\n        if (isInterfaceType(namedType)) {\n          // Store implementations by interface.\n          var _iterator5 = _createForOfIteratorHelper(namedType.getInterfaces()),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var iface = _step5.value;\n\n              if (isInterfaceType(iface)) {\n                var implementations = this._implementationsMap[iface.name];\n\n                if (implementations === undefined) {\n                  implementations = this._implementationsMap[iface.name] = {\n                    objects: [],\n                    interfaces: []\n                  };\n                }\n\n                implementations.interfaces.push(namedType);\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        } else if (isObjectType(namedType)) {\n          // Store implementations by objects.\n          var _iterator6 = _createForOfIteratorHelper(namedType.getInterfaces()),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _iface = _step6.value;\n\n              if (isInterfaceType(_iface)) {\n                var _implementations = this._implementationsMap[_iface.name];\n\n                if (_implementations === undefined) {\n                  _implementations = this._implementationsMap[_iface.name] = {\n                    objects: [],\n                    interfaces: []\n                  };\n                }\n\n                _implementations.objects.push(namedType);\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  _createClass(GraphQLSchema, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'GraphQLSchema';\n    }\n  }, {\n    key: \"getQueryType\",\n    value: function getQueryType() {\n      return this._queryType;\n    }\n  }, {\n    key: \"getMutationType\",\n    value: function getMutationType() {\n      return this._mutationType;\n    }\n  }, {\n    key: \"getSubscriptionType\",\n    value: function getSubscriptionType() {\n      return this._subscriptionType;\n    }\n  }, {\n    key: \"getRootType\",\n    value: function getRootType(operation) {\n      switch (operation) {\n        case OperationTypeNode.QUERY:\n          return this.getQueryType();\n\n        case OperationTypeNode.MUTATION:\n          return this.getMutationType();\n\n        case OperationTypeNode.SUBSCRIPTION:\n          return this.getSubscriptionType();\n      }\n    }\n  }, {\n    key: \"getTypeMap\",\n    value: function getTypeMap() {\n      return this._typeMap;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(name) {\n      return this.getTypeMap()[name];\n    }\n  }, {\n    key: \"getPossibleTypes\",\n    value: function getPossibleTypes(abstractType) {\n      return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;\n    }\n  }, {\n    key: \"getImplementations\",\n    value: function getImplementations(interfaceType) {\n      var implementations = this._implementationsMap[interfaceType.name];\n      return implementations !== null && implementations !== void 0 ? implementations : {\n        objects: [],\n        interfaces: []\n      };\n    }\n  }, {\n    key: \"isSubType\",\n    value: function isSubType(abstractType, maybeSubType) {\n      var map = this._subTypeMap[abstractType.name];\n\n      if (map === undefined) {\n        map = Object.create(null);\n\n        if (isUnionType(abstractType)) {\n          var _iterator7 = _createForOfIteratorHelper(abstractType.getTypes()),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var type = _step7.value;\n              map[type.name] = true;\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        } else {\n          var implementations = this.getImplementations(abstractType);\n\n          var _iterator8 = _createForOfIteratorHelper(implementations.objects),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var _type = _step8.value;\n              map[_type.name] = true;\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n\n          var _iterator9 = _createForOfIteratorHelper(implementations.interfaces),\n              _step9;\n\n          try {\n            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n              var _type2 = _step9.value;\n              map[_type2.name] = true;\n            }\n          } catch (err) {\n            _iterator9.e(err);\n          } finally {\n            _iterator9.f();\n          }\n        }\n\n        this._subTypeMap[abstractType.name] = map;\n      }\n\n      return map[maybeSubType.name] !== undefined;\n    }\n  }, {\n    key: \"getDirectives\",\n    value: function getDirectives() {\n      return this._directives;\n    }\n  }, {\n    key: \"getDirective\",\n    value: function getDirective(name) {\n      return this.getDirectives().find(function (directive) {\n        return directive.name === name;\n      });\n    }\n  }, {\n    key: \"toConfig\",\n    value: function toConfig() {\n      return {\n        description: this.description,\n        query: this.getQueryType(),\n        mutation: this.getMutationType(),\n        subscription: this.getSubscriptionType(),\n        types: Object.values(this.getTypeMap()),\n        directives: this.getDirectives(),\n        extensions: this.extensions,\n        astNode: this.astNode,\n        extensionASTNodes: this.extensionASTNodes,\n        assumeValid: this.__validationErrors !== undefined\n      };\n    }\n  }]);\n\n  return GraphQLSchema;\n}(Symbol.toStringTag);\n\nfunction collectReferencedTypes(type, typeSet) {\n  var namedType = getNamedType(type);\n\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n\n    if (isUnionType(namedType)) {\n      var _iterator10 = _createForOfIteratorHelper(namedType.getTypes()),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var memberType = _step10.value;\n          collectReferencedTypes(memberType, typeSet);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {\n      var _iterator11 = _createForOfIteratorHelper(namedType.getInterfaces()),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var interfaceType = _step11.value;\n          collectReferencedTypes(interfaceType, typeSet);\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      for (var _i = 0, _Object$values = Object.values(namedType.getFields()); _i < _Object$values.length; _i++) {\n        var field = _Object$values[_i];\n        collectReferencedTypes(field.type, typeSet);\n\n        var _iterator12 = _createForOfIteratorHelper(field.args),\n            _step12;\n\n        try {\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            var arg = _step12.value;\n            collectReferencedTypes(arg.type, typeSet);\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n      }\n    } else if (isInputObjectType(namedType)) {\n      for (var _i2 = 0, _Object$values2 = Object.values(namedType.getFields()); _i2 < _Object$values2.length; _i2++) {\n        var _field = _Object$values2[_i2];\n        collectReferencedTypes(_field.type, typeSet);\n      }\n    }\n  }\n\n  return typeSet;\n}","map":{"version":3,"sources":["C:/Users/GATHU/Desktop/node_modules/graphql/type/schema.mjs"],"names":["devAssert","inspect","instanceOf","isObjectLike","toObjMap","OperationTypeNode","getNamedType","isInputObjectType","isInterfaceType","isObjectType","isUnionType","isDirective","specifiedDirectives","__Schema","isSchema","schema","GraphQLSchema","assertSchema","Error","config","_config$extensionASTN","_config$directives","__validationErrors","assumeValid","undefined","types","Array","isArray","directives","description","extensions","astNode","extensionASTNodes","_queryType","query","_mutationType","mutation","_subscriptionType","subscription","_directives","allReferencedTypes","Set","type","delete","collectReferencedTypes","directive","args","arg","_typeMap","Object","create","_subTypeMap","_implementationsMap","namedType","typeName","name","getInterfaces","iface","implementations","objects","interfaces","push","operation","QUERY","getQueryType","MUTATION","getMutationType","SUBSCRIPTION","getSubscriptionType","getTypeMap","abstractType","getTypes","getImplementations","interfaceType","maybeSubType","map","getDirectives","find","values","Symbol","toStringTag","typeSet","has","add","memberType","getFields","field"],"mappings":";;;AAAA,SAASA,SAAT,QAA0B,0BAA1B;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,SAASC,UAAT,QAA2B,2BAA3B;AACA,SAASC,YAAT,QAA6B,6BAA7B;AACA,SAASC,QAAT,QAAyB,yBAAzB;AACA,SAASC,iBAAT,QAAkC,qBAAlC;AACA,SACEC,YADF,EAEEC,iBAFF,EAGEC,eAHF,EAIEC,YAJF,EAKEC,WALF,QAMO,kBANP;AAOA,SAASC,WAAT,EAAsBC,mBAAtB,QAAiD,kBAAjD;AACA,SAASC,QAAT,QAAyB,qBAAzB;AACA;AACA;AACA;;AAEA,OAAO,SAASC,QAAT,CAAkBC,MAAlB,EAA0B;AAC/B,SAAOb,UAAU,CAACa,MAAD,EAASC,aAAT,CAAjB;AACD;AACD,OAAO,SAASC,YAAT,CAAsBF,MAAtB,EAA8B;AACnC,MAAI,CAACD,QAAQ,CAACC,MAAD,CAAb,EAAuB;AACrB,UAAM,IAAIG,KAAJ,oBAAsBjB,OAAO,CAACc,MAAD,CAA7B,8BAAN;AACD;;AAED,SAAOA,MAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,WAAaC,aAAb;AACE;AACA,yBAAYG,MAAZ,EAAoB;AAAA;;AAClB,QAAIC,qBAAJ,EAA2BC,kBAA3B,CADkB,CAGlB;AACA;;;AACA,SAAKC,kBAAL,GAA0BH,MAAM,CAACI,WAAP,KAAuB,IAAvB,GAA8B,EAA9B,GAAmCC,SAA7D,CALkB,CAKsD;;AAExErB,IAAAA,YAAY,CAACg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","sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { instanceOf } from '../jsutils/instanceOf.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { toObjMap } from '../jsutils/toObjMap.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport {\n  getNamedType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isUnionType,\n} from './definition.mjs';\nimport { isDirective, specifiedDirectives } from './directives.mjs';\nimport { __Schema } from './introspection.mjs';\n/**\n * Test if the given value is a GraphQL schema.\n */\n\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\nexport function assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);\n  }\n\n  return schema;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   query: MyAppQueryRootType,\n *   mutation: MyAppMutationRootType,\n * })\n * ```\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n * ```ts\n * const characterInterface = new GraphQLInterfaceType({\n *   name: 'Character',\n *   ...\n * });\n *\n * const humanType = new GraphQLObjectType({\n *   name: 'Human',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const droidType = new GraphQLObjectType({\n *   name: 'Droid',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const schema = new GraphQLSchema({\n *   query: new GraphQLObjectType({\n *     name: 'Query',\n *     fields: {\n *       hero: { type: characterInterface, ... },\n *     }\n *   }),\n *   ...\n *   // Since this schema references only the `Character` interface it's\n *   // necessary to explicitly list the types that implement it if\n *   // you want them to be included in the final schema.\n *   types: [humanType, droidType],\n * })\n * ```\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. `@include` and\n * `@skip`) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   ...\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\n * })\n * ```\n */\nexport class GraphQLSchema {\n  // Used as a cache for validateSchema().\n  constructor(config) {\n    var _config$extensionASTN, _config$directives;\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\n\n    isObjectLike(config) ||\n      devAssert(false, 'Must provide configuration object.');\n    !config.types ||\n      Array.isArray(config.types) ||\n      devAssert(\n        false,\n        `\"types\" must be Array if provided but got: ${inspect(config.types)}.`,\n      );\n    !config.directives ||\n      Array.isArray(config.directives) ||\n      devAssert(\n        false,\n        '\"directives\" must be Array if provided but got: ' +\n          `${inspect(config.directives)}.`,\n      );\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN = config.extensionASTNodes) !== null &&\n      _config$extensionASTN !== void 0\n        ? _config$extensionASTN\n        : [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives =\n      (_config$directives = config.directives) !== null &&\n      _config$directives !== void 0\n        ? _config$directives\n        : specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n\n    const allReferencedTypes = new Set(config.types);\n\n    if (config.types != null) {\n      for (const type of config.types) {\n        // When we ready to process this type, we remove it from \"collected\" types\n        // and then add it together with all dependent types in the correct position.\n        allReferencedTypes.delete(type);\n        collectReferencedTypes(type, allReferencedTypes);\n      }\n    }\n\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n\n    for (const directive of this._directives) {\n      // Directives are not validated until validateSchema() is called.\n      if (isDirective(directive)) {\n        for (const arg of directive.args) {\n          collectReferencedTypes(arg.type, allReferencedTypes);\n        }\n      }\n    }\n\n    collectReferencedTypes(__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = Object.create(null);\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementationsMap = Object.create(null);\n\n    for (const namedType of allReferencedTypes) {\n      if (namedType == null) {\n        continue;\n      }\n\n      const typeName = namedType.name;\n      typeName ||\n        devAssert(\n          false,\n          'One of the provided types for building the Schema is missing a name.',\n        );\n\n      if (this._typeMap[typeName] !== undefined) {\n        throw new Error(\n          `Schema must contain uniquely named types but contains multiple types named \"${typeName}\".`,\n        );\n      }\n\n      this._typeMap[typeName] = namedType;\n\n      if (isInterfaceType(namedType)) {\n        // Store implementations by interface.\n        for (const iface of namedType.getInterfaces()) {\n          if (isInterfaceType(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: [],\n              };\n            }\n\n            implementations.interfaces.push(namedType);\n          }\n        }\n      } else if (isObjectType(namedType)) {\n        // Store implementations by objects.\n        for (const iface of namedType.getInterfaces()) {\n          if (isInterfaceType(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: [],\n              };\n            }\n\n            implementations.objects.push(namedType);\n          }\n        }\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLSchema';\n  }\n\n  getQueryType() {\n    return this._queryType;\n  }\n\n  getMutationType() {\n    return this._mutationType;\n  }\n\n  getSubscriptionType() {\n    return this._subscriptionType;\n  }\n\n  getRootType(operation) {\n    switch (operation) {\n      case OperationTypeNode.QUERY:\n        return this.getQueryType();\n\n      case OperationTypeNode.MUTATION:\n        return this.getMutationType();\n\n      case OperationTypeNode.SUBSCRIPTION:\n        return this.getSubscriptionType();\n    }\n  }\n\n  getTypeMap() {\n    return this._typeMap;\n  }\n\n  getType(name) {\n    return this.getTypeMap()[name];\n  }\n\n  getPossibleTypes(abstractType) {\n    return isUnionType(abstractType)\n      ? abstractType.getTypes()\n      : this.getImplementations(abstractType).objects;\n  }\n\n  getImplementations(interfaceType) {\n    const implementations = this._implementationsMap[interfaceType.name];\n    return implementations !== null && implementations !== void 0\n      ? implementations\n      : {\n          objects: [],\n          interfaces: [],\n        };\n  }\n\n  isSubType(abstractType, maybeSubType) {\n    let map = this._subTypeMap[abstractType.name];\n\n    if (map === undefined) {\n      map = Object.create(null);\n\n      if (isUnionType(abstractType)) {\n        for (const type of abstractType.getTypes()) {\n          map[type.name] = true;\n        }\n      } else {\n        const implementations = this.getImplementations(abstractType);\n\n        for (const type of implementations.objects) {\n          map[type.name] = true;\n        }\n\n        for (const type of implementations.interfaces) {\n          map[type.name] = true;\n        }\n      }\n\n      this._subTypeMap[abstractType.name] = map;\n    }\n\n    return map[maybeSubType.name] !== undefined;\n  }\n\n  getDirectives() {\n    return this._directives;\n  }\n\n  getDirective(name) {\n    return this.getDirectives().find((directive) => directive.name === name);\n  }\n\n  toConfig() {\n    return {\n      description: this.description,\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: Object.values(this.getTypeMap()),\n      directives: this.getDirectives(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n      assumeValid: this.__validationErrors !== undefined,\n    };\n  }\n}\n\nfunction collectReferencedTypes(type, typeSet) {\n  const namedType = getNamedType(type);\n\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n\n    if (isUnionType(namedType)) {\n      for (const memberType of namedType.getTypes()) {\n        collectReferencedTypes(memberType, typeSet);\n      }\n    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {\n      for (const interfaceType of namedType.getInterfaces()) {\n        collectReferencedTypes(interfaceType, typeSet);\n      }\n\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n\n        for (const arg of field.args) {\n          collectReferencedTypes(arg.type, typeSet);\n        }\n      }\n    } else if (isInputObjectType(namedType)) {\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n      }\n    }\n  }\n\n  return typeSet;\n}\n"]},"metadata":{},"sourceType":"module"}