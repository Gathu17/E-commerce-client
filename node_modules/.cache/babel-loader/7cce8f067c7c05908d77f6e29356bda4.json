{"ast":null,"code":"import _classCallCheck from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { syntaxError } from '../error/syntaxError.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Kind } from './kinds.mjs';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\nimport { isSource, Source } from './source.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\n\nexport function parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nexport function parseConstValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport var Parser = /*#__PURE__*/function () {\n  function Parser(source, options) {\n    _classCallCheck(this, Parser);\n\n    var sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  _createClass(Parser, [{\n    key: \"parseName\",\n    value: function parseName() {\n      var token = this.expectToken(TokenKind.NAME);\n      return this.node(token, {\n        kind: Kind.NAME,\n        value: token.value\n      });\n    } // Implements the parsing rules in the Document section.\n\n    /**\n     * Document : Definition+\n     */\n\n  }, {\n    key: \"parseDocument\",\n    value: function parseDocument() {\n      return this.node(this._lexer.token, {\n        kind: Kind.DOCUMENT,\n        definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF)\n      });\n    }\n    /**\n     * Definition :\n     *   - ExecutableDefinition\n     *   - TypeSystemDefinition\n     *   - TypeSystemExtension\n     *\n     * ExecutableDefinition :\n     *   - OperationDefinition\n     *   - FragmentDefinition\n     *\n     * TypeSystemDefinition :\n     *   - SchemaDefinition\n     *   - TypeDefinition\n     *   - DirectiveDefinition\n     *\n     * TypeDefinition :\n     *   - ScalarTypeDefinition\n     *   - ObjectTypeDefinition\n     *   - InterfaceTypeDefinition\n     *   - UnionTypeDefinition\n     *   - EnumTypeDefinition\n     *   - InputObjectTypeDefinition\n     */\n\n  }, {\n    key: \"parseDefinition\",\n    value: function parseDefinition() {\n      if (this.peek(TokenKind.BRACE_L)) {\n        return this.parseOperationDefinition();\n      } // Many definitions begin with a description and require a lookahead.\n\n\n      var hasDescription = this.peekDescription();\n      var keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;\n\n      if (keywordToken.kind === TokenKind.NAME) {\n        switch (keywordToken.value) {\n          case 'schema':\n            return this.parseSchemaDefinition();\n\n          case 'scalar':\n            return this.parseScalarTypeDefinition();\n\n          case 'type':\n            return this.parseObjectTypeDefinition();\n\n          case 'interface':\n            return this.parseInterfaceTypeDefinition();\n\n          case 'union':\n            return this.parseUnionTypeDefinition();\n\n          case 'enum':\n            return this.parseEnumTypeDefinition();\n\n          case 'input':\n            return this.parseInputObjectTypeDefinition();\n\n          case 'directive':\n            return this.parseDirectiveDefinition();\n        }\n\n        if (hasDescription) {\n          throw syntaxError(this._lexer.source, this._lexer.token.start, 'Unexpected description, descriptions are supported only on type definitions.');\n        }\n\n        switch (keywordToken.value) {\n          case 'query':\n          case 'mutation':\n          case 'subscription':\n            return this.parseOperationDefinition();\n\n          case 'fragment':\n            return this.parseFragmentDefinition();\n\n          case 'extend':\n            return this.parseTypeSystemExtension();\n        }\n      }\n\n      throw this.unexpected(keywordToken);\n    } // Implements the parsing rules in the Operations section.\n\n    /**\n     * OperationDefinition :\n     *  - SelectionSet\n     *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n     */\n\n  }, {\n    key: \"parseOperationDefinition\",\n    value: function parseOperationDefinition() {\n      var start = this._lexer.token;\n\n      if (this.peek(TokenKind.BRACE_L)) {\n        return this.node(start, {\n          kind: Kind.OPERATION_DEFINITION,\n          operation: OperationTypeNode.QUERY,\n          name: undefined,\n          variableDefinitions: [],\n          directives: [],\n          selectionSet: this.parseSelectionSet()\n        });\n      }\n\n      var operation = this.parseOperationType();\n      var name;\n\n      if (this.peek(TokenKind.NAME)) {\n        name = this.parseName();\n      }\n\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: operation,\n        name: name,\n        variableDefinitions: this.parseVariableDefinitions(),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n    /**\n     * OperationType : one of query mutation subscription\n     */\n\n  }, {\n    key: \"parseOperationType\",\n    value: function parseOperationType() {\n      var operationToken = this.expectToken(TokenKind.NAME);\n\n      switch (operationToken.value) {\n        case 'query':\n          return OperationTypeNode.QUERY;\n\n        case 'mutation':\n          return OperationTypeNode.MUTATION;\n\n        case 'subscription':\n          return OperationTypeNode.SUBSCRIPTION;\n      }\n\n      throw this.unexpected(operationToken);\n    }\n    /**\n     * VariableDefinitions : ( VariableDefinition+ )\n     */\n\n  }, {\n    key: \"parseVariableDefinitions\",\n    value: function parseVariableDefinitions() {\n      return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n    }\n    /**\n     * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n     */\n\n  }, {\n    key: \"parseVariableDefinition\",\n    value: function parseVariableDefinition() {\n      return this.node(this._lexer.token, {\n        kind: Kind.VARIABLE_DEFINITION,\n        variable: this.parseVariable(),\n        type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n        defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,\n        directives: this.parseConstDirectives()\n      });\n    }\n    /**\n     * Variable : $ Name\n     */\n\n  }, {\n    key: \"parseVariable\",\n    value: function parseVariable() {\n      var start = this._lexer.token;\n      this.expectToken(TokenKind.DOLLAR);\n      return this.node(start, {\n        kind: Kind.VARIABLE,\n        name: this.parseName()\n      });\n    }\n    /**\n     * ```\n     * SelectionSet : { Selection+ }\n     * ```\n     */\n\n  }, {\n    key: \"parseSelectionSet\",\n    value: function parseSelectionSet() {\n      return this.node(this._lexer.token, {\n        kind: Kind.SELECTION_SET,\n        selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R)\n      });\n    }\n    /**\n     * Selection :\n     *   - Field\n     *   - FragmentSpread\n     *   - InlineFragment\n     */\n\n  }, {\n    key: \"parseSelection\",\n    value: function parseSelection() {\n      return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n    }\n    /**\n     * Field : Alias? Name Arguments? Directives? SelectionSet?\n     *\n     * Alias : Name :\n     */\n\n  }, {\n    key: \"parseField\",\n    value: function parseField() {\n      var start = this._lexer.token;\n      var nameOrAlias = this.parseName();\n      var alias;\n      var name;\n\n      if (this.expectOptionalToken(TokenKind.COLON)) {\n        alias = nameOrAlias;\n        name = this.parseName();\n      } else {\n        name = nameOrAlias;\n      }\n\n      return this.node(start, {\n        kind: Kind.FIELD,\n        alias: alias,\n        name: name,\n        arguments: this.parseArguments(false),\n        directives: this.parseDirectives(false),\n        selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined\n      });\n    }\n    /**\n     * Arguments[Const] : ( Argument[?Const]+ )\n     */\n\n  }, {\n    key: \"parseArguments\",\n    value: function parseArguments(isConst) {\n      var item = isConst ? this.parseConstArgument : this.parseArgument;\n      return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n    }\n    /**\n     * Argument[Const] : Name : Value[?Const]\n     */\n\n  }, {\n    key: \"parseArgument\",\n    value: function parseArgument() {\n      var isConst = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var start = this._lexer.token;\n      var name = this.parseName();\n      this.expectToken(TokenKind.COLON);\n      return this.node(start, {\n        kind: Kind.ARGUMENT,\n        name: name,\n        value: this.parseValueLiteral(isConst)\n      });\n    }\n  }, {\n    key: \"parseConstArgument\",\n    value: function parseConstArgument() {\n      return this.parseArgument(true);\n    } // Implements the parsing rules in the Fragments section.\n\n    /**\n     * Corresponds to both FragmentSpread and InlineFragment in the spec.\n     *\n     * FragmentSpread : ... FragmentName Directives?\n     *\n     * InlineFragment : ... TypeCondition? Directives? SelectionSet\n     */\n\n  }, {\n    key: \"parseFragment\",\n    value: function parseFragment() {\n      var start = this._lexer.token;\n      this.expectToken(TokenKind.SPREAD);\n      var hasTypeCondition = this.expectOptionalKeyword('on');\n\n      if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n        return this.node(start, {\n          kind: Kind.FRAGMENT_SPREAD,\n          name: this.parseFragmentName(),\n          directives: this.parseDirectives(false)\n        });\n      }\n\n      return this.node(start, {\n        kind: Kind.INLINE_FRAGMENT,\n        typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n    /**\n     * FragmentDefinition :\n     *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n     *\n     * TypeCondition : NamedType\n     */\n\n  }, {\n    key: \"parseFragmentDefinition\",\n    value: function parseFragmentDefinition() {\n      var _this$_options;\n\n      var start = this._lexer.token;\n      this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n      // the grammar of FragmentDefinition:\n      //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n      if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.allowLegacyFragmentVariables) === true) {\n        return this.node(start, {\n          kind: Kind.FRAGMENT_DEFINITION,\n          name: this.parseFragmentName(),\n          variableDefinitions: this.parseVariableDefinitions(),\n          typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n          directives: this.parseDirectives(false),\n          selectionSet: this.parseSelectionSet()\n        });\n      }\n\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n    /**\n     * FragmentName : Name but not `on`\n     */\n\n  }, {\n    key: \"parseFragmentName\",\n    value: function parseFragmentName() {\n      if (this._lexer.token.value === 'on') {\n        throw this.unexpected();\n      }\n\n      return this.parseName();\n    } // Implements the parsing rules in the Values section.\n\n    /**\n     * Value[Const] :\n     *   - [~Const] Variable\n     *   - IntValue\n     *   - FloatValue\n     *   - StringValue\n     *   - BooleanValue\n     *   - NullValue\n     *   - EnumValue\n     *   - ListValue[?Const]\n     *   - ObjectValue[?Const]\n     *\n     * BooleanValue : one of `true` `false`\n     *\n     * NullValue : `null`\n     *\n     * EnumValue : Name but not `true`, `false` or `null`\n     */\n\n  }, {\n    key: \"parseValueLiteral\",\n    value: function parseValueLiteral(isConst) {\n      var token = this._lexer.token;\n\n      switch (token.kind) {\n        case TokenKind.BRACKET_L:\n          return this.parseList(isConst);\n\n        case TokenKind.BRACE_L:\n          return this.parseObject(isConst);\n\n        case TokenKind.INT:\n          this._lexer.advance();\n\n          return this.node(token, {\n            kind: Kind.INT,\n            value: token.value\n          });\n\n        case TokenKind.FLOAT:\n          this._lexer.advance();\n\n          return this.node(token, {\n            kind: Kind.FLOAT,\n            value: token.value\n          });\n\n        case TokenKind.STRING:\n        case TokenKind.BLOCK_STRING:\n          return this.parseStringLiteral();\n\n        case TokenKind.NAME:\n          this._lexer.advance();\n\n          switch (token.value) {\n            case 'true':\n              return this.node(token, {\n                kind: Kind.BOOLEAN,\n                value: true\n              });\n\n            case 'false':\n              return this.node(token, {\n                kind: Kind.BOOLEAN,\n                value: false\n              });\n\n            case 'null':\n              return this.node(token, {\n                kind: Kind.NULL\n              });\n\n            default:\n              return this.node(token, {\n                kind: Kind.ENUM,\n                value: token.value\n              });\n          }\n\n        case TokenKind.DOLLAR:\n          if (isConst) {\n            this.expectToken(TokenKind.DOLLAR);\n\n            if (this._lexer.token.kind === TokenKind.NAME) {\n              var varName = this._lexer.token.value;\n              throw syntaxError(this._lexer.source, token.start, \"Unexpected variable \\\"$\".concat(varName, \"\\\" in constant value.\"));\n            } else {\n              throw this.unexpected(token);\n            }\n          }\n\n          return this.parseVariable();\n\n        default:\n          throw this.unexpected();\n      }\n    }\n  }, {\n    key: \"parseConstValueLiteral\",\n    value: function parseConstValueLiteral() {\n      return this.parseValueLiteral(true);\n    }\n  }, {\n    key: \"parseStringLiteral\",\n    value: function parseStringLiteral() {\n      var token = this._lexer.token;\n\n      this._lexer.advance();\n\n      return this.node(token, {\n        kind: Kind.STRING,\n        value: token.value,\n        block: token.kind === TokenKind.BLOCK_STRING\n      });\n    }\n    /**\n     * ListValue[Const] :\n     *   - [ ]\n     *   - [ Value[?Const]+ ]\n     */\n\n  }, {\n    key: \"parseList\",\n    value: function parseList(isConst) {\n      var _this = this;\n\n      var item = function item() {\n        return _this.parseValueLiteral(isConst);\n      };\n\n      return this.node(this._lexer.token, {\n        kind: Kind.LIST,\n        values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)\n      });\n    }\n    /**\n     * ```\n     * ObjectValue[Const] :\n     *   - { }\n     *   - { ObjectField[?Const]+ }\n     * ```\n     */\n\n  }, {\n    key: \"parseObject\",\n    value: function parseObject(isConst) {\n      var _this2 = this;\n\n      var item = function item() {\n        return _this2.parseObjectField(isConst);\n      };\n\n      return this.node(this._lexer.token, {\n        kind: Kind.OBJECT,\n        fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)\n      });\n    }\n    /**\n     * ObjectField[Const] : Name : Value[?Const]\n     */\n\n  }, {\n    key: \"parseObjectField\",\n    value: function parseObjectField(isConst) {\n      var start = this._lexer.token;\n      var name = this.parseName();\n      this.expectToken(TokenKind.COLON);\n      return this.node(start, {\n        kind: Kind.OBJECT_FIELD,\n        name: name,\n        value: this.parseValueLiteral(isConst)\n      });\n    } // Implements the parsing rules in the Directives section.\n\n    /**\n     * Directives[Const] : Directive[?Const]+\n     */\n\n  }, {\n    key: \"parseDirectives\",\n    value: function parseDirectives(isConst) {\n      var directives = [];\n\n      while (this.peek(TokenKind.AT)) {\n        directives.push(this.parseDirective(isConst));\n      }\n\n      return directives;\n    }\n  }, {\n    key: \"parseConstDirectives\",\n    value: function parseConstDirectives() {\n      return this.parseDirectives(true);\n    }\n    /**\n     * ```\n     * Directive[Const] : @ Name Arguments[?Const]?\n     * ```\n     */\n\n  }, {\n    key: \"parseDirective\",\n    value: function parseDirective(isConst) {\n      var start = this._lexer.token;\n      this.expectToken(TokenKind.AT);\n      return this.node(start, {\n        kind: Kind.DIRECTIVE,\n        name: this.parseName(),\n        arguments: this.parseArguments(isConst)\n      });\n    } // Implements the parsing rules in the Types section.\n\n    /**\n     * Type :\n     *   - NamedType\n     *   - ListType\n     *   - NonNullType\n     */\n\n  }, {\n    key: \"parseTypeReference\",\n    value: function parseTypeReference() {\n      var start = this._lexer.token;\n      var type;\n\n      if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n        var innerType = this.parseTypeReference();\n        this.expectToken(TokenKind.BRACKET_R);\n        type = this.node(start, {\n          kind: Kind.LIST_TYPE,\n          type: innerType\n        });\n      } else {\n        type = this.parseNamedType();\n      }\n\n      if (this.expectOptionalToken(TokenKind.BANG)) {\n        return this.node(start, {\n          kind: Kind.NON_NULL_TYPE,\n          type: type\n        });\n      }\n\n      return type;\n    }\n    /**\n     * NamedType : Name\n     */\n\n  }, {\n    key: \"parseNamedType\",\n    value: function parseNamedType() {\n      return this.node(this._lexer.token, {\n        kind: Kind.NAMED_TYPE,\n        name: this.parseName()\n      });\n    } // Implements the parsing rules in the Type Definition section.\n\n  }, {\n    key: \"peekDescription\",\n    value: function peekDescription() {\n      return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n    }\n    /**\n     * Description : StringValue\n     */\n\n  }, {\n    key: \"parseDescription\",\n    value: function parseDescription() {\n      if (this.peekDescription()) {\n        return this.parseStringLiteral();\n      }\n    }\n    /**\n     * ```\n     * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n     * ```\n     */\n\n  }, {\n    key: \"parseSchemaDefinition\",\n    value: function parseSchemaDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      this.expectKeyword('schema');\n      var directives = this.parseConstDirectives();\n      var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n      return this.node(start, {\n        kind: Kind.SCHEMA_DEFINITION,\n        description: description,\n        directives: directives,\n        operationTypes: operationTypes\n      });\n    }\n    /**\n     * OperationTypeDefinition : OperationType : NamedType\n     */\n\n  }, {\n    key: \"parseOperationTypeDefinition\",\n    value: function parseOperationTypeDefinition() {\n      var start = this._lexer.token;\n      var operation = this.parseOperationType();\n      this.expectToken(TokenKind.COLON);\n      var type = this.parseNamedType();\n      return this.node(start, {\n        kind: Kind.OPERATION_TYPE_DEFINITION,\n        operation: operation,\n        type: type\n      });\n    }\n    /**\n     * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n     */\n\n  }, {\n    key: \"parseScalarTypeDefinition\",\n    value: function parseScalarTypeDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      this.expectKeyword('scalar');\n      var name = this.parseName();\n      var directives = this.parseConstDirectives();\n      return this.node(start, {\n        kind: Kind.SCALAR_TYPE_DEFINITION,\n        description: description,\n        name: name,\n        directives: directives\n      });\n    }\n    /**\n     * ObjectTypeDefinition :\n     *   Description?\n     *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n     */\n\n  }, {\n    key: \"parseObjectTypeDefinition\",\n    value: function parseObjectTypeDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      this.expectKeyword('type');\n      var name = this.parseName();\n      var interfaces = this.parseImplementsInterfaces();\n      var directives = this.parseConstDirectives();\n      var fields = this.parseFieldsDefinition();\n      return this.node(start, {\n        kind: Kind.OBJECT_TYPE_DEFINITION,\n        description: description,\n        name: name,\n        interfaces: interfaces,\n        directives: directives,\n        fields: fields\n      });\n    }\n    /**\n     * ImplementsInterfaces :\n     *   - implements `&`? NamedType\n     *   - ImplementsInterfaces & NamedType\n     */\n\n  }, {\n    key: \"parseImplementsInterfaces\",\n    value: function parseImplementsInterfaces() {\n      return this.expectOptionalKeyword('implements') ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];\n    }\n    /**\n     * ```\n     * FieldsDefinition : { FieldDefinition+ }\n     * ```\n     */\n\n  }, {\n    key: \"parseFieldsDefinition\",\n    value: function parseFieldsDefinition() {\n      return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n    }\n    /**\n     * FieldDefinition :\n     *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n     */\n\n  }, {\n    key: \"parseFieldDefinition\",\n    value: function parseFieldDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      var name = this.parseName();\n      var args = this.parseArgumentDefs();\n      this.expectToken(TokenKind.COLON);\n      var type = this.parseTypeReference();\n      var directives = this.parseConstDirectives();\n      return this.node(start, {\n        kind: Kind.FIELD_DEFINITION,\n        description: description,\n        name: name,\n        arguments: args,\n        type: type,\n        directives: directives\n      });\n    }\n    /**\n     * ArgumentsDefinition : ( InputValueDefinition+ )\n     */\n\n  }, {\n    key: \"parseArgumentDefs\",\n    value: function parseArgumentDefs() {\n      return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n    }\n    /**\n     * InputValueDefinition :\n     *   - Description? Name : Type DefaultValue? Directives[Const]?\n     */\n\n  }, {\n    key: \"parseInputValueDef\",\n    value: function parseInputValueDef() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      var name = this.parseName();\n      this.expectToken(TokenKind.COLON);\n      var type = this.parseTypeReference();\n      var defaultValue;\n\n      if (this.expectOptionalToken(TokenKind.EQUALS)) {\n        defaultValue = this.parseConstValueLiteral();\n      }\n\n      var directives = this.parseConstDirectives();\n      return this.node(start, {\n        kind: Kind.INPUT_VALUE_DEFINITION,\n        description: description,\n        name: name,\n        type: type,\n        defaultValue: defaultValue,\n        directives: directives\n      });\n    }\n    /**\n     * InterfaceTypeDefinition :\n     *   - Description? interface Name Directives[Const]? FieldsDefinition?\n     */\n\n  }, {\n    key: \"parseInterfaceTypeDefinition\",\n    value: function parseInterfaceTypeDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      this.expectKeyword('interface');\n      var name = this.parseName();\n      var interfaces = this.parseImplementsInterfaces();\n      var directives = this.parseConstDirectives();\n      var fields = this.parseFieldsDefinition();\n      return this.node(start, {\n        kind: Kind.INTERFACE_TYPE_DEFINITION,\n        description: description,\n        name: name,\n        interfaces: interfaces,\n        directives: directives,\n        fields: fields\n      });\n    }\n    /**\n     * UnionTypeDefinition :\n     *   - Description? union Name Directives[Const]? UnionMemberTypes?\n     */\n\n  }, {\n    key: \"parseUnionTypeDefinition\",\n    value: function parseUnionTypeDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      this.expectKeyword('union');\n      var name = this.parseName();\n      var directives = this.parseConstDirectives();\n      var types = this.parseUnionMemberTypes();\n      return this.node(start, {\n        kind: Kind.UNION_TYPE_DEFINITION,\n        description: description,\n        name: name,\n        directives: directives,\n        types: types\n      });\n    }\n    /**\n     * UnionMemberTypes :\n     *   - = `|`? NamedType\n     *   - UnionMemberTypes | NamedType\n     */\n\n  }, {\n    key: \"parseUnionMemberTypes\",\n    value: function parseUnionMemberTypes() {\n      return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];\n    }\n    /**\n     * EnumTypeDefinition :\n     *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n     */\n\n  }, {\n    key: \"parseEnumTypeDefinition\",\n    value: function parseEnumTypeDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      this.expectKeyword('enum');\n      var name = this.parseName();\n      var directives = this.parseConstDirectives();\n      var values = this.parseEnumValuesDefinition();\n      return this.node(start, {\n        kind: Kind.ENUM_TYPE_DEFINITION,\n        description: description,\n        name: name,\n        directives: directives,\n        values: values\n      });\n    }\n    /**\n     * ```\n     * EnumValuesDefinition : { EnumValueDefinition+ }\n     * ```\n     */\n\n  }, {\n    key: \"parseEnumValuesDefinition\",\n    value: function parseEnumValuesDefinition() {\n      return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n    }\n    /**\n     * EnumValueDefinition : Description? EnumValue Directives[Const]?\n     */\n\n  }, {\n    key: \"parseEnumValueDefinition\",\n    value: function parseEnumValueDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      var name = this.parseEnumValueName();\n      var directives = this.parseConstDirectives();\n      return this.node(start, {\n        kind: Kind.ENUM_VALUE_DEFINITION,\n        description: description,\n        name: name,\n        directives: directives\n      });\n    }\n    /**\n     * EnumValue : Name but not `true`, `false` or `null`\n     */\n\n  }, {\n    key: \"parseEnumValueName\",\n    value: function parseEnumValueName() {\n      if (this._lexer.token.value === 'true' || this._lexer.token.value === 'false' || this._lexer.token.value === 'null') {\n        throw syntaxError(this._lexer.source, this._lexer.token.start, \"\".concat(getTokenDesc(this._lexer.token), \" is reserved and cannot be used for an enum value.\"));\n      }\n\n      return this.parseName();\n    }\n    /**\n     * InputObjectTypeDefinition :\n     *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n     */\n\n  }, {\n    key: \"parseInputObjectTypeDefinition\",\n    value: function parseInputObjectTypeDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      this.expectKeyword('input');\n      var name = this.parseName();\n      var directives = this.parseConstDirectives();\n      var fields = this.parseInputFieldsDefinition();\n      return this.node(start, {\n        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        description: description,\n        name: name,\n        directives: directives,\n        fields: fields\n      });\n    }\n    /**\n     * ```\n     * InputFieldsDefinition : { InputValueDefinition+ }\n     * ```\n     */\n\n  }, {\n    key: \"parseInputFieldsDefinition\",\n    value: function parseInputFieldsDefinition() {\n      return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n    }\n    /**\n     * TypeSystemExtension :\n     *   - SchemaExtension\n     *   - TypeExtension\n     *\n     * TypeExtension :\n     *   - ScalarTypeExtension\n     *   - ObjectTypeExtension\n     *   - InterfaceTypeExtension\n     *   - UnionTypeExtension\n     *   - EnumTypeExtension\n     *   - InputObjectTypeDefinition\n     */\n\n  }, {\n    key: \"parseTypeSystemExtension\",\n    value: function parseTypeSystemExtension() {\n      var keywordToken = this._lexer.lookahead();\n\n      if (keywordToken.kind === TokenKind.NAME) {\n        switch (keywordToken.value) {\n          case 'schema':\n            return this.parseSchemaExtension();\n\n          case 'scalar':\n            return this.parseScalarTypeExtension();\n\n          case 'type':\n            return this.parseObjectTypeExtension();\n\n          case 'interface':\n            return this.parseInterfaceTypeExtension();\n\n          case 'union':\n            return this.parseUnionTypeExtension();\n\n          case 'enum':\n            return this.parseEnumTypeExtension();\n\n          case 'input':\n            return this.parseInputObjectTypeExtension();\n        }\n      }\n\n      throw this.unexpected(keywordToken);\n    }\n    /**\n     * ```\n     * SchemaExtension :\n     *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n     *  - extend schema Directives[Const]\n     * ```\n     */\n\n  }, {\n    key: \"parseSchemaExtension\",\n    value: function parseSchemaExtension() {\n      var start = this._lexer.token;\n      this.expectKeyword('extend');\n      this.expectKeyword('schema');\n      var directives = this.parseConstDirectives();\n      var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n      if (directives.length === 0 && operationTypes.length === 0) {\n        throw this.unexpected();\n      }\n\n      return this.node(start, {\n        kind: Kind.SCHEMA_EXTENSION,\n        directives: directives,\n        operationTypes: operationTypes\n      });\n    }\n    /**\n     * ScalarTypeExtension :\n     *   - extend scalar Name Directives[Const]\n     */\n\n  }, {\n    key: \"parseScalarTypeExtension\",\n    value: function parseScalarTypeExtension() {\n      var start = this._lexer.token;\n      this.expectKeyword('extend');\n      this.expectKeyword('scalar');\n      var name = this.parseName();\n      var directives = this.parseConstDirectives();\n\n      if (directives.length === 0) {\n        throw this.unexpected();\n      }\n\n      return this.node(start, {\n        kind: Kind.SCALAR_TYPE_EXTENSION,\n        name: name,\n        directives: directives\n      });\n    }\n    /**\n     * ObjectTypeExtension :\n     *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n     *  - extend type Name ImplementsInterfaces? Directives[Const]\n     *  - extend type Name ImplementsInterfaces\n     */\n\n  }, {\n    key: \"parseObjectTypeExtension\",\n    value: function parseObjectTypeExtension() {\n      var start = this._lexer.token;\n      this.expectKeyword('extend');\n      this.expectKeyword('type');\n      var name = this.parseName();\n      var interfaces = this.parseImplementsInterfaces();\n      var directives = this.parseConstDirectives();\n      var fields = this.parseFieldsDefinition();\n\n      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n        throw this.unexpected();\n      }\n\n      return this.node(start, {\n        kind: Kind.OBJECT_TYPE_EXTENSION,\n        name: name,\n        interfaces: interfaces,\n        directives: directives,\n        fields: fields\n      });\n    }\n    /**\n     * InterfaceTypeExtension :\n     *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n     *  - extend interface Name ImplementsInterfaces? Directives[Const]\n     *  - extend interface Name ImplementsInterfaces\n     */\n\n  }, {\n    key: \"parseInterfaceTypeExtension\",\n    value: function parseInterfaceTypeExtension() {\n      var start = this._lexer.token;\n      this.expectKeyword('extend');\n      this.expectKeyword('interface');\n      var name = this.parseName();\n      var interfaces = this.parseImplementsInterfaces();\n      var directives = this.parseConstDirectives();\n      var fields = this.parseFieldsDefinition();\n\n      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n        throw this.unexpected();\n      }\n\n      return this.node(start, {\n        kind: Kind.INTERFACE_TYPE_EXTENSION,\n        name: name,\n        interfaces: interfaces,\n        directives: directives,\n        fields: fields\n      });\n    }\n    /**\n     * UnionTypeExtension :\n     *   - extend union Name Directives[Const]? UnionMemberTypes\n     *   - extend union Name Directives[Const]\n     */\n\n  }, {\n    key: \"parseUnionTypeExtension\",\n    value: function parseUnionTypeExtension() {\n      var start = this._lexer.token;\n      this.expectKeyword('extend');\n      this.expectKeyword('union');\n      var name = this.parseName();\n      var directives = this.parseConstDirectives();\n      var types = this.parseUnionMemberTypes();\n\n      if (directives.length === 0 && types.length === 0) {\n        throw this.unexpected();\n      }\n\n      return this.node(start, {\n        kind: Kind.UNION_TYPE_EXTENSION,\n        name: name,\n        directives: directives,\n        types: types\n      });\n    }\n    /**\n     * EnumTypeExtension :\n     *   - extend enum Name Directives[Const]? EnumValuesDefinition\n     *   - extend enum Name Directives[Const]\n     */\n\n  }, {\n    key: \"parseEnumTypeExtension\",\n    value: function parseEnumTypeExtension() {\n      var start = this._lexer.token;\n      this.expectKeyword('extend');\n      this.expectKeyword('enum');\n      var name = this.parseName();\n      var directives = this.parseConstDirectives();\n      var values = this.parseEnumValuesDefinition();\n\n      if (directives.length === 0 && values.length === 0) {\n        throw this.unexpected();\n      }\n\n      return this.node(start, {\n        kind: Kind.ENUM_TYPE_EXTENSION,\n        name: name,\n        directives: directives,\n        values: values\n      });\n    }\n    /**\n     * InputObjectTypeExtension :\n     *   - extend input Name Directives[Const]? InputFieldsDefinition\n     *   - extend input Name Directives[Const]\n     */\n\n  }, {\n    key: \"parseInputObjectTypeExtension\",\n    value: function parseInputObjectTypeExtension() {\n      var start = this._lexer.token;\n      this.expectKeyword('extend');\n      this.expectKeyword('input');\n      var name = this.parseName();\n      var directives = this.parseConstDirectives();\n      var fields = this.parseInputFieldsDefinition();\n\n      if (directives.length === 0 && fields.length === 0) {\n        throw this.unexpected();\n      }\n\n      return this.node(start, {\n        kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n        name: name,\n        directives: directives,\n        fields: fields\n      });\n    }\n    /**\n     * ```\n     * DirectiveDefinition :\n     *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n     * ```\n     */\n\n  }, {\n    key: \"parseDirectiveDefinition\",\n    value: function parseDirectiveDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      this.expectKeyword('directive');\n      this.expectToken(TokenKind.AT);\n      var name = this.parseName();\n      var args = this.parseArgumentDefs();\n      var repeatable = this.expectOptionalKeyword('repeatable');\n      this.expectKeyword('on');\n      var locations = this.parseDirectiveLocations();\n      return this.node(start, {\n        kind: Kind.DIRECTIVE_DEFINITION,\n        description: description,\n        name: name,\n        arguments: args,\n        repeatable: repeatable,\n        locations: locations\n      });\n    }\n    /**\n     * DirectiveLocations :\n     *   - `|`? DirectiveLocation\n     *   - DirectiveLocations | DirectiveLocation\n     */\n\n  }, {\n    key: \"parseDirectiveLocations\",\n    value: function parseDirectiveLocations() {\n      return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n    }\n    /*\n     * DirectiveLocation :\n     *   - ExecutableDirectiveLocation\n     *   - TypeSystemDirectiveLocation\n     *\n     * ExecutableDirectiveLocation : one of\n     *   `QUERY`\n     *   `MUTATION`\n     *   `SUBSCRIPTION`\n     *   `FIELD`\n     *   `FRAGMENT_DEFINITION`\n     *   `FRAGMENT_SPREAD`\n     *   `INLINE_FRAGMENT`\n     *\n     * TypeSystemDirectiveLocation : one of\n     *   `SCHEMA`\n     *   `SCALAR`\n     *   `OBJECT`\n     *   `FIELD_DEFINITION`\n     *   `ARGUMENT_DEFINITION`\n     *   `INTERFACE`\n     *   `UNION`\n     *   `ENUM`\n     *   `ENUM_VALUE`\n     *   `INPUT_OBJECT`\n     *   `INPUT_FIELD_DEFINITION`\n     */\n\n  }, {\n    key: \"parseDirectiveLocation\",\n    value: function parseDirectiveLocation() {\n      var start = this._lexer.token;\n      var name = this.parseName();\n\n      if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n        return name;\n      }\n\n      throw this.unexpected(start);\n    } // Core parsing utility functions\n\n    /**\n     * Returns a node that, if configured to do so, sets a \"loc\" field as a\n     * location object, used to identify the place in the source that created a\n     * given parsed object.\n     */\n\n  }, {\n    key: \"node\",\n    value: function node(startToken, _node) {\n      var _this$_options2;\n\n      if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.noLocation) !== true) {\n        _node.loc = new Location(startToken, this._lexer.lastToken, this._lexer.source);\n      }\n\n      return _node;\n    }\n    /**\n     * Determines if the next token is of a given kind\n     */\n\n  }, {\n    key: \"peek\",\n    value: function peek(kind) {\n      return this._lexer.token.kind === kind;\n    }\n    /**\n     * If the next token is of the given kind, return that token after advancing the lexer.\n     * Otherwise, do not change the parser state and throw an error.\n     */\n\n  }, {\n    key: \"expectToken\",\n    value: function expectToken(kind) {\n      var token = this._lexer.token;\n\n      if (token.kind === kind) {\n        this._lexer.advance();\n\n        return token;\n      }\n\n      throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(getTokenKindDesc(kind), \", found \").concat(getTokenDesc(token), \".\"));\n    }\n    /**\n     * If the next token is of the given kind, return \"true\" after advancing the lexer.\n     * Otherwise, do not change the parser state and return \"false\".\n     */\n\n  }, {\n    key: \"expectOptionalToken\",\n    value: function expectOptionalToken(kind) {\n      var token = this._lexer.token;\n\n      if (token.kind === kind) {\n        this._lexer.advance();\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * If the next token is a given keyword, advance the lexer.\n     * Otherwise, do not change the parser state and throw an error.\n     */\n\n  }, {\n    key: \"expectKeyword\",\n    value: function expectKeyword(value) {\n      var token = this._lexer.token;\n\n      if (token.kind === TokenKind.NAME && token.value === value) {\n        this._lexer.advance();\n      } else {\n        throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token), \".\"));\n      }\n    }\n    /**\n     * If the next token is a given keyword, return \"true\" after advancing the lexer.\n     * Otherwise, do not change the parser state and return \"false\".\n     */\n\n  }, {\n    key: \"expectOptionalKeyword\",\n    value: function expectOptionalKeyword(value) {\n      var token = this._lexer.token;\n\n      if (token.kind === TokenKind.NAME && token.value === value) {\n        this._lexer.advance();\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Helper function for creating an error when an unexpected lexed token is encountered.\n     */\n\n  }, {\n    key: \"unexpected\",\n    value: function unexpected(atToken) {\n      var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n      return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token), \".\"));\n    }\n    /**\n     * Returns a possibly empty list of parse nodes, determined by the parseFn.\n     * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n     * Advances the parser to the next lex token after the closing token.\n     */\n\n  }, {\n    key: \"any\",\n    value: function any(openKind, parseFn, closeKind) {\n      this.expectToken(openKind);\n      var nodes = [];\n\n      while (!this.expectOptionalToken(closeKind)) {\n        nodes.push(parseFn.call(this));\n      }\n\n      return nodes;\n    }\n    /**\n     * Returns a list of parse nodes, determined by the parseFn.\n     * It can be empty only if open token is missing otherwise it will always return non-empty list\n     * that begins with a lex token of openKind and ends with a lex token of closeKind.\n     * Advances the parser to the next lex token after the closing token.\n     */\n\n  }, {\n    key: \"optionalMany\",\n    value: function optionalMany(openKind, parseFn, closeKind) {\n      if (this.expectOptionalToken(openKind)) {\n        var nodes = [];\n\n        do {\n          nodes.push(parseFn.call(this));\n        } while (!this.expectOptionalToken(closeKind));\n\n        return nodes;\n      }\n\n      return [];\n    }\n    /**\n     * Returns a non-empty list of parse nodes, determined by the parseFn.\n     * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n     * Advances the parser to the next lex token after the closing token.\n     */\n\n  }, {\n    key: \"many\",\n    value: function many(openKind, parseFn, closeKind) {\n      this.expectToken(openKind);\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n    /**\n     * Returns a non-empty list of parse nodes, determined by the parseFn.\n     * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n     * Advances the parser to the next lex token after last item in the list.\n     */\n\n  }, {\n    key: \"delimitedMany\",\n    value: function delimitedMany(delimiterKind, parseFn) {\n      this.expectOptionalToken(delimiterKind);\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (this.expectOptionalToken(delimiterKind));\n\n      return nodes;\n    }\n  }]);\n\n  return Parser;\n}();\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? \" \\\"\".concat(value, \"\\\"\") : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? \"\\\"\".concat(kind, \"\\\"\") : kind;\n}","map":{"version":3,"sources":["C:/Users/GATHU/Desktop/node_modules/graphql/language/parser.mjs"],"names":["syntaxError","Location","OperationTypeNode","DirectiveLocation","Kind","isPunctuatorTokenKind","Lexer","isSource","Source","TokenKind","parse","source","options","parser","Parser","parseDocument","parseValue","expectToken","SOF","value","parseValueLiteral","EOF","parseConstValue","parseConstValueLiteral","parseType","type","parseTypeReference","sourceObj","_lexer","_options","token","NAME","node","kind","DOCUMENT","definitions","many","parseDefinition","peek","BRACE_L","parseOperationDefinition","hasDescription","peekDescription","keywordToken","lookahead","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","start","parseFragmentDefinition","parseTypeSystemExtension","unexpected","OPERATION_DEFINITION","operation","QUERY","name","undefined","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseName","parseVariableDefinitions","parseDirectives","operationToken","MUTATION","SUBSCRIPTION","optionalMany","PAREN_L","parseVariableDefinition","PAREN_R","VARIABLE_DEFINITION","variable","parseVariable","COLON","defaultValue","expectOptionalToken","EQUALS","parseConstDirectives","DOLLAR","VARIABLE","SELECTION_SET","selections","parseSelection","BRACE_R","SPREAD","parseFragment","parseField","nameOrAlias","alias","FIELD","arguments","parseArguments","isConst","item","parseConstArgument","parseArgument","ARGUMENT","hasTypeCondition","expectOptionalKeyword","FRAGMENT_SPREAD","parseFragmentName","INLINE_FRAGMENT","typeCondition","parseNamedType","_this$_options","expectKeyword","allowLegacyFragmentVariables","FRAGMENT_DEFINITION","BRACKET_L","parseList","parseObject","INT","advance","FLOAT","STRING","BLOCK_STRING","parseStringLiteral","BOOLEAN","NULL","ENUM","varName","block","LIST","values","any","BRACKET_R","parseObjectField","OBJECT","fields","OBJECT_FIELD","AT","push","parseDirective","DIRECTIVE","innerType","LIST_TYPE","BANG","NON_NULL_TYPE","NAMED_TYPE","description","parseDescription","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","delimitedMany","AMP","parseFieldDefinition","args","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","types","parseUnionMemberTypes","UNION_TYPE_DEFINITION","PIPE","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumValueDefinition","parseEnumValueName","ENUM_VALUE_DEFINITION","getTokenDesc","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","length","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","repeatable","locations","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveLocation","Object","prototype","hasOwnProperty","call","startToken","_this$_options2","noLocation","loc","lastToken","getTokenKindDesc","atToken","openKind","parseFn","closeKind","nodes","delimiterKind"],"mappings":"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","sourcesContent":["import { syntaxError } from '../error/syntaxError.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Kind } from './kinds.mjs';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\nimport { isSource, Source } from './source.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nexport function parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport class Parser {\n  constructor(source, options) {\n    const sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  parseName() {\n    const token = this.expectToken(TokenKind.NAME);\n    return this.node(token, {\n      kind: Kind.NAME,\n      value: token.value,\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(\n        TokenKind.SOF,\n        this.parseDefinition,\n        TokenKind.EOF,\n      ),\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n  parseDefinition() {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription\n      ? this._lexer.lookahead()\n      : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw syntaxError(\n          this._lexer.source,\n          this._lexer.token.start,\n          'Unexpected description, descriptions are supported only on type definitions.',\n        );\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseVariableDefinition,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS)\n        ? this.parseConstValueLiteral()\n        : undefined,\n      directives: this.parseConstDirectives(),\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(\n        TokenKind.BRACE_L,\n        this.parseSelection,\n        TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n  parseSelection() {\n    return this.peek(TokenKind.SPREAD)\n      ? this.parseFragment()\n      : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L)\n        ? this.parseSelectionSet()\n        : undefined,\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n  parseFragmentDefinition() {\n    var _this$_options;\n\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (\n      ((_this$_options = this._options) === null || _this$_options === void 0\n        ? void 0\n        : _this$_options.allowLegacyFragmentVariables) === true\n    ) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: Kind.INT,\n          value: token.value,\n        });\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: Kind.FLOAT,\n          value: token.value,\n        });\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: true,\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: false,\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: Kind.NULL,\n            });\n\n          default:\n            return this.node(token, {\n              kind: Kind.ENUM,\n              value: token.value,\n            });\n        }\n\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError(\n              this._lexer.source,\n              token.start,\n              `Unexpected variable \"$${varName}\" in constant value.`,\n            );\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return this.node(token, {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node(start, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: Kind.LIST_TYPE,\n        type: innerType,\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node(start, {\n        kind: Kind.NON_NULL_TYPE,\n        type,\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n    return this.node(start, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type,\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements')\n      ? this.delimitedMany(TokenKind.AMP, this.parseNamedType)\n      : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseFieldDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives,\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseInputValueDef,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives,\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS)\n      ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType)\n      : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseEnumValueDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseEnumValueName() {\n    if (\n      this._lexer.token.value === 'true' ||\n      this._lexer.token.value === 'false' ||\n      this._lexer.token.value === 'null'\n    ) {\n      throw syntaxError(\n        this._lexer.source,\n        this._lexer.token.start,\n        `${getTokenDesc(\n          this._lexer.token,\n        )} is reserved and cannot be used for an enum value.`,\n      );\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseInputValueDef,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations,\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n  node(startToken, node) {\n    var _this$_options2;\n\n    if (\n      ((_this$_options2 = this._options) === null || _this$_options2 === void 0\n        ? void 0\n        : _this$_options2.noLocation) !== true\n    ) {\n      node.loc = new Location(\n        startToken,\n        this._lexer.lastToken,\n        this._lexer.source,\n      );\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(\n      this._lexer.source,\n      token.start,\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(\n        this._lexer.source,\n        token.start,\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\n      );\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n  unexpected(atToken) {\n    const token =\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(\n      this._lexer.source,\n      token.start,\n      `Unexpected ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\n}\n"]},"metadata":{},"sourceType":"module"}