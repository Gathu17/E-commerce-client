{"ast":null,"code":"import _slicedToArray from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { isPromise } from '../jsutils/isPromise.mjs';\nimport { memoize3 } from '../jsutils/memoize3.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { promiseForObject } from '../jsutils/promiseForObject.mjs';\nimport { promiseReduce } from '../jsutils/promiseReduce.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { isAbstractType, isLeafType, isListType, isNonNullType, isObjectType } from '../type/definition.mjs';\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from '../type/introspection.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport { collectFields, collectSubfields as _collectSubfields } from './collectFields.mjs';\nimport { getArgumentValues, getVariableValues } from './values.mjs';\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\n\nvar collectSubfields = memoize3(function (exeContext, returnType, fieldNodes) {\n  return _collectSubfields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes);\n});\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g `a`\n * 2) fragment \"spreads\" e.g. `...c`\n * 3) inline fragment \"spreads\" e.g. `...on Type { a }`\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\n\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification.\n *\n * Returns either a synchronous ExecutionResult (if all encountered resolvers\n * are synchronous), or a Promise of an ExecutionResult that will eventually be\n * resolved and never rejected.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\n\nexport function execute(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 || devAssert(false, 'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.');\n  var schema = args.schema,\n      document = args.document,\n      variableValues = args.variableValues,\n      rootValue = args.rootValue; // If arguments are missing or incorrect, throw an error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  var exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext\n    };\n  } // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n  //\n  // Errors from sub-fields of a NonNull type may propagate to the top level,\n  // at which point we still log the error and null the parent field, which\n  // in this case is the entire response.\n\n\n  try {\n    var operation = exeContext.operation;\n    var result = executeOperation(exeContext, operation, rootValue);\n\n    if (isPromise(result)) {\n      return result.then(function (data) {\n        return buildResponse(data, exeContext.errors);\n      }, function (error) {\n        exeContext.errors.push(error);\n        return buildResponse(null, exeContext.errors);\n      });\n    }\n\n    return buildResponse(result, exeContext.errors);\n  } catch (error) {\n    exeContext.errors.push(error);\n    return buildResponse(null, exeContext.errors);\n  }\n}\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\nexport function executeSync(args) {\n  var result = execute(args); // Assert that the execution was synchronous.\n\n  if (isPromise(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n/**\n * Given a completed execution context and data, build the `{ errors, data }`\n * response defined by the \"Response\" section of the GraphQL specification.\n */\n\nfunction buildResponse(data, errors) {\n  return errors.length === 0 ? {\n    data: data\n  } : {\n    errors: errors,\n    data: data\n  };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\n\n\nexport function assertValidExecutionArguments(schema, document, rawVariableValues) {\n  document || devAssert(false, 'Must provide document.'); // If the schema used for execution is invalid, throw an error.\n\n  assertValidSchema(schema); // Variables, if provided, must be an object.\n\n  rawVariableValues == null || isObjectLike(rawVariableValues) || devAssert(false, 'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.');\n}\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * @internal\n */\n\nexport function buildExecutionContext(args) {\n  var _definition$name, _operation$variableDe;\n\n  var schema = args.schema,\n      document = args.document,\n      rootValue = args.rootValue,\n      contextValue = args.contextValue,\n      rawVariableValues = args.variableValues,\n      operationName = args.operationName,\n      fieldResolver = args.fieldResolver,\n      typeResolver = args.typeResolver,\n      subscribeFieldResolver = args.subscribeFieldResolver;\n  var operation;\n  var fragments = Object.create(null);\n\n  var _iterator = _createForOfIteratorHelper(document.definitions),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var definition = _step.value;\n\n      switch (definition.kind) {\n        case Kind.OPERATION_DEFINITION:\n          if (operationName == null) {\n            if (operation !== undefined) {\n              return [new GraphQLError('Must provide operation name if query contains multiple operations.')];\n            }\n\n            operation = definition;\n          } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {\n            operation = definition;\n          }\n\n          break;\n\n        case Kind.FRAGMENT_DEFINITION:\n          fragments[definition.name.value] = definition;\n          break;\n\n        default: // ignore non-executable definitions\n\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (!operation) {\n    if (operationName != null) {\n      return [new GraphQLError(\"Unknown operation named \\\"\".concat(operationName, \"\\\".\"))];\n    }\n\n    return [new GraphQLError('Must provide an operation.')];\n  } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n\n  var variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];\n  var coercedVariableValues = getVariableValues(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {\n    maxErrors: 50\n  });\n\n  if (coercedVariableValues.errors) {\n    return coercedVariableValues.errors;\n  }\n\n  return {\n    schema: schema,\n    fragments: fragments,\n    rootValue: rootValue,\n    contextValue: contextValue,\n    operation: operation,\n    variableValues: coercedVariableValues.coerced,\n    fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,\n    typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,\n    subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,\n    errors: []\n  };\n}\n/**\n * Implements the \"Executing operations\" section of the spec.\n */\n\nfunction executeOperation(exeContext, operation, rootValue) {\n  var rootType = exeContext.schema.getRootType(operation.operation);\n\n  if (rootType == null) {\n    throw new GraphQLError(\"Schema is not configured to execute \".concat(operation.operation, \" operation.\"), operation);\n  }\n\n  var rootFields = collectFields(exeContext.schema, exeContext.fragments, exeContext.variableValues, rootType, operation.selectionSet);\n  var path = undefined;\n\n  switch (operation.operation) {\n    case OperationTypeNode.QUERY:\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n\n    case OperationTypeNode.MUTATION:\n      return executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);\n\n    case OperationTypeNode.SUBSCRIPTION:\n      // TODO: deprecate `subscribe` and move all logic here\n      // Temporary solution until we finish merging execute and subscribe together\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n  }\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that must be executed serially.\n */\n\n\nfunction executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {\n  return promiseReduce(fields.entries(), function (results, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        responseName = _ref2[0],\n        fieldNodes = _ref2[1];\n\n    var fieldPath = addPath(path, responseName, parentType.name);\n    var result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);\n\n    if (result === undefined) {\n      return results;\n    }\n\n    if (isPromise(result)) {\n      return result.then(function (resolvedResult) {\n        results[responseName] = resolvedResult;\n        return results;\n      });\n    }\n\n    results[responseName] = result;\n    return results;\n  }, Object.create(null));\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that may be executed in parallel.\n */\n\n\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  var results = Object.create(null);\n  var containsPromise = false;\n\n  var _iterator2 = _createForOfIteratorHelper(fields.entries()),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n          responseName = _step2$value[0],\n          fieldNodes = _step2$value[1];\n\n      var fieldPath = addPath(path, responseName, parentType.name);\n      var result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);\n\n      if (result !== undefined) {\n        results[responseName] = result;\n\n        if (isPromise(result)) {\n          containsPromise = true;\n        }\n      }\n    } // If there are no promises, we can just return the object\n\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  if (!containsPromise) {\n    return results;\n  } // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n\n\n  return promiseForObject(results);\n}\n/**\n * Implements the \"Executing fields\" section of the spec\n * In particular, this function figures out the value that the field returns by\n * calling its resolve function, then calls completeValue to complete promises,\n * serialize scalars, or execute the sub-selection-set for objects.\n */\n\n\nfunction executeField(exeContext, parentType, source, fieldNodes, path) {\n  var _fieldDef$resolve;\n\n  var fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    return;\n  }\n\n  var returnType = fieldDef.type;\n  var resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;\n  var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path); // Get the resolve function, regardless of if its result is normal or abrupt (error).\n\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    var args = getArgumentValues(fieldDef, fieldNodes[0], exeContext.variableValues); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    var contextValue = exeContext.contextValue;\n    var result = resolveFn(source, args, contextValue, info);\n    var completed;\n\n    if (isPromise(result)) {\n      completed = result.then(function (resolved) {\n        return completeValue(exeContext, returnType, fieldNodes, info, path, resolved);\n      });\n    } else {\n      completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);\n    }\n\n    if (isPromise(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, function (rawError) {\n        var error = locatedError(rawError, fieldNodes, pathToArray(path));\n        return handleFieldError(error, returnType, exeContext);\n      });\n    }\n\n    return completed;\n  } catch (rawError) {\n    var error = locatedError(rawError, fieldNodes, pathToArray(path));\n    return handleFieldError(error, returnType, exeContext);\n  }\n}\n/**\n * @internal\n */\n\n\nexport function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes: fieldNodes,\n    returnType: fieldDef.type,\n    parentType: parentType,\n    path: path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues\n  };\n}\n\nfunction handleFieldError(error, returnType, exeContext) {\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n  if (isNonNullType(returnType)) {\n    throw error;\n  } // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n\n\n  exeContext.errors.push(error);\n  return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Value Completion\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by executing all sub-selections.\n */\n\n\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  } // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n\n\n  if (isNonNullType(returnType)) {\n    var completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);\n\n    if (completed === null) {\n      throw new Error(\"Cannot return null for non-nullable field \".concat(info.parentType.name, \".\").concat(info.fieldName, \".\"));\n    }\n\n    return completed;\n  } // If result value is null or undefined then return null.\n\n\n  if (result == null) {\n    return null;\n  } // If field type is List, complete each item in the list with the inner type\n\n\n  if (isListType(returnType)) {\n    return completeListValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n\n\n  if (isLeafType(returnType)) {\n    return completeLeafValue(returnType, result);\n  } // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n\n\n  if (isAbstractType(returnType)) {\n    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // If field type is Object, execute and complete all sub-selections.\n\n\n  if (isObjectType(returnType)) {\n    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);\n  }\n  /* c8 ignore next 6 */\n  // Not reachable, all possible output types have been considered.\n\n\n  false || invariant(false, 'Cannot complete value of unexpected output type: ' + inspect(returnType));\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\n\n\nfunction completeListValue(exeContext, returnType, fieldNodes, info, path, result) {\n  if (!isIterableObject(result)) {\n    throw new GraphQLError(\"Expected Iterable, but did not find one for field \\\"\".concat(info.parentType.name, \".\").concat(info.fieldName, \"\\\".\"));\n  } // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n\n\n  var itemType = returnType.ofType;\n  var containsPromise = false;\n  var completedResults = Array.from(result, function (item, index) {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    var itemPath = addPath(path, index, undefined);\n\n    try {\n      var completedItem;\n\n      if (isPromise(item)) {\n        completedItem = item.then(function (resolved) {\n          return completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved);\n        });\n      } else {\n        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);\n      }\n\n      if (isPromise(completedItem)) {\n        containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n        // to take a second callback for the error case.\n\n        return completedItem.then(undefined, function (rawError) {\n          var error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n          return handleFieldError(error, itemType, exeContext);\n        });\n      }\n\n      return completedItem;\n    } catch (rawError) {\n      var error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n      return handleFieldError(error, itemType, exeContext);\n    }\n  });\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\n\n\nfunction completeLeafValue(returnType, result) {\n  var serializedResult = returnType.serialize(result);\n\n  if (serializedResult == null) {\n    throw new Error(\"Expected `\".concat(inspect(returnType), \".serialize(\").concat(inspect(result), \")` to \") + \"return non-nullable value, returned: \".concat(inspect(serializedResult)));\n  }\n\n  return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\n\n\nfunction completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {\n  var _returnType$resolveTy;\n\n  var resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;\n  var contextValue = exeContext.contextValue;\n  var runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n\n  if (isPromise(runtimeType)) {\n    return runtimeType.then(function (resolvedRuntimeType) {\n      return completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);\n    });\n  }\n\n  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);\n}\n\nfunction ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {\n  if (runtimeTypeName == null) {\n    throw new GraphQLError(\"Abstract type \\\"\".concat(returnType.name, \"\\\" must resolve to an Object type at runtime for field \\\"\").concat(info.parentType.name, \".\").concat(info.fieldName, \"\\\". Either the \\\"\").concat(returnType.name, \"\\\" type should provide a \\\"resolveType\\\" function or each possible type should provide an \\\"isTypeOf\\\" function.\"), fieldNodes);\n  } // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\n  // TODO: remove in 17.0.0 release\n\n\n  if (isObjectType(runtimeTypeName)) {\n    throw new GraphQLError('Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.');\n  }\n\n  if (typeof runtimeTypeName !== 'string') {\n    throw new GraphQLError(\"Abstract type \\\"\".concat(returnType.name, \"\\\" must resolve to an Object type at runtime for field \\\"\").concat(info.parentType.name, \".\").concat(info.fieldName, \"\\\" with \") + \"value \".concat(inspect(result), \", received \\\"\").concat(inspect(runtimeTypeName), \"\\\".\"));\n  }\n\n  var runtimeType = exeContext.schema.getType(runtimeTypeName);\n\n  if (runtimeType == null) {\n    throw new GraphQLError(\"Abstract type \\\"\".concat(returnType.name, \"\\\" was resolved to a type \\\"\").concat(runtimeTypeName, \"\\\" that does not exist inside the schema.\"), fieldNodes);\n  }\n\n  if (!isObjectType(runtimeType)) {\n    throw new GraphQLError(\"Abstract type \\\"\".concat(returnType.name, \"\\\" was resolved to a non-object type \\\"\").concat(runtimeTypeName, \"\\\".\"), fieldNodes);\n  }\n\n  if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n    throw new GraphQLError(\"Runtime Object type \\\"\".concat(runtimeType.name, \"\\\" is not a possible type for \\\"\").concat(returnType.name, \"\\\".\"), fieldNodes);\n  }\n\n  return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\n\n\nfunction completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // Collect sub-fields to execute to complete this value.\n  var subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes); // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n\n  if (returnType.isTypeOf) {\n    var isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n\n    if (isPromise(isTypeOf)) {\n      return isTypeOf.then(function (resolvedIsTypeOf) {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n\n        return executeFields(exeContext, returnType, result, path, subFieldNodes);\n      });\n    }\n\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\n    }\n  }\n\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\n}\n\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n  return new GraphQLError(\"Expected value of type \\\"\".concat(returnType.name, \"\\\" but got: \").concat(inspect(result), \".\"), fieldNodes);\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\n\n\nexport var defaultTypeResolver = function defaultTypeResolver(value, contextValue, info, abstractType) {\n  // First, look for `__typename`.\n  if (isObjectLike(value) && typeof value.__typename === 'string') {\n    return value.__typename;\n  } // Otherwise, test each possible type.\n\n\n  var possibleTypes = info.schema.getPossibleTypes(abstractType);\n  var promisedIsTypeOfResults = [];\n\n  for (var i = 0; i < possibleTypes.length; i++) {\n    var type = possibleTypes[i];\n\n    if (type.isTypeOf) {\n      var isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n      if (isPromise(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        return type.name;\n      }\n    }\n  }\n\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then(function (isTypeOfResults) {\n      for (var _i = 0; _i < isTypeOfResults.length; _i++) {\n        if (isTypeOfResults[_i]) {\n          return possibleTypes[_i].name;\n        }\n      }\n    });\n  }\n};\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\n\nexport var defaultFieldResolver = function defaultFieldResolver(source, args, contextValue, info) {\n  // ensure source is a value for which property access is acceptable.\n  if (isObjectLike(source) || typeof source === 'function') {\n    var property = source[info.fieldName];\n\n    if (typeof property === 'function') {\n      return source[info.fieldName](args, contextValue, info);\n    }\n\n    return property;\n  }\n};\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\n\nexport function getFieldDef(schema, parentType, fieldNode) {\n  var fieldName = fieldNode.name.value;\n\n  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  } else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  } else if (fieldName === TypeNameMetaFieldDef.name) {\n    return TypeNameMetaFieldDef;\n  }\n\n  return parentType.getFields()[fieldName];\n}","map":{"version":3,"sources":["C:/Users/GATHU/Desktop/node_modules/graphql/execution/execute.mjs"],"names":["devAssert","inspect","invariant","isIterableObject","isObjectLike","isPromise","memoize3","addPath","pathToArray","promiseForObject","promiseReduce","GraphQLError","locatedError","OperationTypeNode","Kind","isAbstractType","isLeafType","isListType","isNonNullType","isObjectType","SchemaMetaFieldDef","TypeMetaFieldDef","TypeNameMetaFieldDef","assertValidSchema","collectFields","collectSubfields","_collectSubfields","getArgumentValues","getVariableValues","exeContext","returnType","fieldNodes","schema","fragments","variableValues","execute","args","arguments","length","document","rootValue","assertValidExecutionArguments","buildExecutionContext","errors","operation","result","executeOperation","then","data","buildResponse","error","push","executeSync","Error","rawVariableValues","_definition$name","_operation$variableDe","contextValue","operationName","fieldResolver","typeResolver","subscribeFieldResolver","Object","create","definitions","definition","kind","OPERATION_DEFINITION","undefined","name","value","FRAGMENT_DEFINITION","variableDefinitions","coercedVariableValues","maxErrors","coerced","defaultFieldResolver","defaultTypeResolver","rootType","getRootType","rootFields","selectionSet","path","QUERY","executeFields","MUTATION","executeFieldsSerially","SUBSCRIPTION","parentType","sourceValue","fields","entries","results","responseName","fieldPath","executeField","resolvedResult","containsPromise","source","_fieldDef$resolve","fieldDef","getFieldDef","type","resolveFn","resolve","info","buildResolveInfo","completed","resolved","completeValue","rawError","handleFieldError","fieldName","ofType","completeListValue","completeLeafValue","completeAbstractValue","completeObjectValue","itemType","completedResults","Array","from","item","index","itemPath","completedItem","Promise","all","serializedResult","serialize","_returnType$resolveTy","resolveTypeFn","resolveType","runtimeType","resolvedRuntimeType","ensureValidRuntimeType","runtimeTypeName","getType","isSubType","subFieldNodes","isTypeOf","resolvedIsTypeOf","invalidReturnTypeError","abstractType","__typename","possibleTypes","getPossibleTypes","promisedIsTypeOfResults","i","isTypeOfResult","isTypeOfResults","property","fieldNode","getQueryType","getFields"],"mappings":"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","sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { isPromise } from '../jsutils/isPromise.mjs';\nimport { memoize3 } from '../jsutils/memoize3.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { promiseForObject } from '../jsutils/promiseForObject.mjs';\nimport { promiseReduce } from '../jsutils/promiseReduce.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport {\n  isAbstractType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../type/definition.mjs';\nimport {\n  SchemaMetaFieldDef,\n  TypeMetaFieldDef,\n  TypeNameMetaFieldDef,\n} from '../type/introspection.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport {\n  collectFields,\n  collectSubfields as _collectSubfields,\n} from './collectFields.mjs';\nimport { getArgumentValues, getVariableValues } from './values.mjs';\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\n\nconst collectSubfields = memoize3((exeContext, returnType, fieldNodes) =>\n  _collectSubfields(\n    exeContext.schema,\n    exeContext.fragments,\n    exeContext.variableValues,\n    returnType,\n    fieldNodes,\n  ),\n);\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g `a`\n * 2) fragment \"spreads\" e.g. `...c`\n * 3) inline fragment \"spreads\" e.g. `...on Type { a }`\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\n\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification.\n *\n * Returns either a synchronous ExecutionResult (if all encountered resolvers\n * are synchronous), or a Promise of an ExecutionResult that will eventually be\n * resolved and never rejected.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\nexport function execute(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const { schema, document, variableValues, rootValue } = args; // If arguments are missing or incorrect, throw an error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  } // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n  //\n  // Errors from sub-fields of a NonNull type may propagate to the top level,\n  // at which point we still log the error and null the parent field, which\n  // in this case is the entire response.\n\n  try {\n    const { operation } = exeContext;\n    const result = executeOperation(exeContext, operation, rootValue);\n\n    if (isPromise(result)) {\n      return result.then(\n        (data) => buildResponse(data, exeContext.errors),\n        (error) => {\n          exeContext.errors.push(error);\n          return buildResponse(null, exeContext.errors);\n        },\n      );\n    }\n\n    return buildResponse(result, exeContext.errors);\n  } catch (error) {\n    exeContext.errors.push(error);\n    return buildResponse(null, exeContext.errors);\n  }\n}\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\nexport function executeSync(args) {\n  const result = execute(args); // Assert that the execution was synchronous.\n\n  if (isPromise(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n/**\n * Given a completed execution context and data, build the `{ errors, data }`\n * response defined by the \"Response\" section of the GraphQL specification.\n */\n\nfunction buildResponse(data, errors) {\n  return errors.length === 0\n    ? {\n        data,\n      }\n    : {\n        errors,\n        data,\n      };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\n\nexport function assertValidExecutionArguments(\n  schema,\n  document,\n  rawVariableValues,\n) {\n  document || devAssert(false, 'Must provide document.'); // If the schema used for execution is invalid, throw an error.\n\n  assertValidSchema(schema); // Variables, if provided, must be an object.\n\n  rawVariableValues == null ||\n    isObjectLike(rawVariableValues) ||\n    devAssert(\n      false,\n      'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.',\n    );\n}\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * @internal\n */\n\nexport function buildExecutionContext(args) {\n  var _definition$name, _operation$variableDe;\n\n  const {\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues: rawVariableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n    subscribeFieldResolver,\n  } = args;\n  let operation;\n  const fragments = Object.create(null);\n\n  for (const definition of document.definitions) {\n    switch (definition.kind) {\n      case Kind.OPERATION_DEFINITION:\n        if (operationName == null) {\n          if (operation !== undefined) {\n            return [\n              new GraphQLError(\n                'Must provide operation name if query contains multiple operations.',\n              ),\n            ];\n          }\n\n          operation = definition;\n        } else if (\n          ((_definition$name = definition.name) === null ||\n          _definition$name === void 0\n            ? void 0\n            : _definition$name.value) === operationName\n        ) {\n          operation = definition;\n        }\n\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  }\n\n  if (!operation) {\n    if (operationName != null) {\n      return [new GraphQLError(`Unknown operation named \"${operationName}\".`)];\n    }\n\n    return [new GraphQLError('Must provide an operation.')];\n  } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const variableDefinitions =\n    (_operation$variableDe = operation.variableDefinitions) !== null &&\n    _operation$variableDe !== void 0\n      ? _operation$variableDe\n      : [];\n  const coercedVariableValues = getVariableValues(\n    schema,\n    variableDefinitions,\n    rawVariableValues !== null && rawVariableValues !== void 0\n      ? rawVariableValues\n      : {},\n    {\n      maxErrors: 50,\n    },\n  );\n\n  if (coercedVariableValues.errors) {\n    return coercedVariableValues.errors;\n  }\n\n  return {\n    schema,\n    fragments,\n    rootValue,\n    contextValue,\n    operation,\n    variableValues: coercedVariableValues.coerced,\n    fieldResolver:\n      fieldResolver !== null && fieldResolver !== void 0\n        ? fieldResolver\n        : defaultFieldResolver,\n    typeResolver:\n      typeResolver !== null && typeResolver !== void 0\n        ? typeResolver\n        : defaultTypeResolver,\n    subscribeFieldResolver:\n      subscribeFieldResolver !== null && subscribeFieldResolver !== void 0\n        ? subscribeFieldResolver\n        : defaultFieldResolver,\n    errors: [],\n  };\n}\n/**\n * Implements the \"Executing operations\" section of the spec.\n */\n\nfunction executeOperation(exeContext, operation, rootValue) {\n  const rootType = exeContext.schema.getRootType(operation.operation);\n\n  if (rootType == null) {\n    throw new GraphQLError(\n      `Schema is not configured to execute ${operation.operation} operation.`,\n      operation,\n    );\n  }\n\n  const rootFields = collectFields(\n    exeContext.schema,\n    exeContext.fragments,\n    exeContext.variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const path = undefined;\n\n  switch (operation.operation) {\n    case OperationTypeNode.QUERY:\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n\n    case OperationTypeNode.MUTATION:\n      return executeFieldsSerially(\n        exeContext,\n        rootType,\n        rootValue,\n        path,\n        rootFields,\n      );\n\n    case OperationTypeNode.SUBSCRIPTION:\n      // TODO: deprecate `subscribe` and move all logic here\n      // Temporary solution until we finish merging execute and subscribe together\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n  }\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that must be executed serially.\n */\n\nfunction executeFieldsSerially(\n  exeContext,\n  parentType,\n  sourceValue,\n  path,\n  fields,\n) {\n  return promiseReduce(\n    fields.entries(),\n    (results, [responseName, fieldNodes]) => {\n      const fieldPath = addPath(path, responseName, parentType.name);\n      const result = executeField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldNodes,\n        fieldPath,\n      );\n\n      if (result === undefined) {\n        return results;\n      }\n\n      if (isPromise(result)) {\n        return result.then((resolvedResult) => {\n          results[responseName] = resolvedResult;\n          return results;\n        });\n      }\n\n      results[responseName] = result;\n      return results;\n    },\n    Object.create(null),\n  );\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that may be executed in parallel.\n */\n\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  const results = Object.create(null);\n  let containsPromise = false;\n\n  for (const [responseName, fieldNodes] of fields.entries()) {\n    const fieldPath = addPath(path, responseName, parentType.name);\n    const result = executeField(\n      exeContext,\n      parentType,\n      sourceValue,\n      fieldNodes,\n      fieldPath,\n    );\n\n    if (result !== undefined) {\n      results[responseName] = result;\n\n      if (isPromise(result)) {\n        containsPromise = true;\n      }\n    }\n  } // If there are no promises, we can just return the object\n\n  if (!containsPromise) {\n    return results;\n  } // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n\n  return promiseForObject(results);\n}\n/**\n * Implements the \"Executing fields\" section of the spec\n * In particular, this function figures out the value that the field returns by\n * calling its resolve function, then calls completeValue to complete promises,\n * serialize scalars, or execute the sub-selection-set for objects.\n */\n\nfunction executeField(exeContext, parentType, source, fieldNodes, path) {\n  var _fieldDef$resolve;\n\n  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    return;\n  }\n\n  const returnType = fieldDef.type;\n  const resolveFn =\n    (_fieldDef$resolve = fieldDef.resolve) !== null &&\n    _fieldDef$resolve !== void 0\n      ? _fieldDef$resolve\n      : exeContext.fieldResolver;\n  const info = buildResolveInfo(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    parentType,\n    path,\n  ); // Get the resolve function, regardless of if its result is normal or abrupt (error).\n\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    const args = getArgumentValues(\n      fieldDef,\n      fieldNodes[0],\n      exeContext.variableValues,\n    ); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue;\n    const result = resolveFn(source, args, contextValue, info);\n    let completed;\n\n    if (isPromise(result)) {\n      completed = result.then((resolved) =>\n        completeValue(exeContext, returnType, fieldNodes, info, path, resolved),\n      );\n    } else {\n      completed = completeValue(\n        exeContext,\n        returnType,\n        fieldNodes,\n        info,\n        path,\n        result,\n      );\n    }\n\n    if (isPromise(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, (rawError) => {\n        const error = locatedError(rawError, fieldNodes, pathToArray(path));\n        return handleFieldError(error, returnType, exeContext);\n      });\n    }\n\n    return completed;\n  } catch (rawError) {\n    const error = locatedError(rawError, fieldNodes, pathToArray(path));\n    return handleFieldError(error, returnType, exeContext);\n  }\n}\n/**\n * @internal\n */\n\nexport function buildResolveInfo(\n  exeContext,\n  fieldDef,\n  fieldNodes,\n  parentType,\n  path,\n) {\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes,\n    returnType: fieldDef.type,\n    parentType,\n    path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues,\n  };\n}\n\nfunction handleFieldError(error, returnType, exeContext) {\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n  if (isNonNullType(returnType)) {\n    throw error;\n  } // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n\n  exeContext.errors.push(error);\n  return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Value Completion\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by executing all sub-selections.\n */\n\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  } // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n\n  if (isNonNullType(returnType)) {\n    const completed = completeValue(\n      exeContext,\n      returnType.ofType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n\n    if (completed === null) {\n      throw new Error(\n        `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`,\n      );\n    }\n\n    return completed;\n  } // If result value is null or undefined then return null.\n\n  if (result == null) {\n    return null;\n  } // If field type is List, complete each item in the list with the inner type\n\n  if (isListType(returnType)) {\n    return completeListValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n\n  if (isLeafType(returnType)) {\n    return completeLeafValue(returnType, result);\n  } // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n\n  if (isAbstractType(returnType)) {\n    return completeAbstractValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is Object, execute and complete all sub-selections.\n\n  if (isObjectType(returnType)) {\n    return completeObjectValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  }\n  /* c8 ignore next 6 */\n  // Not reachable, all possible output types have been considered.\n\n  false ||\n    invariant(\n      false,\n      'Cannot complete value of unexpected output type: ' + inspect(returnType),\n    );\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\n\nfunction completeListValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  if (!isIterableObject(result)) {\n    throw new GraphQLError(\n      `Expected Iterable, but did not find one for field \"${info.parentType.name}.${info.fieldName}\".`,\n    );\n  } // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n\n  const itemType = returnType.ofType;\n  let containsPromise = false;\n  const completedResults = Array.from(result, (item, index) => {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    const itemPath = addPath(path, index, undefined);\n\n    try {\n      let completedItem;\n\n      if (isPromise(item)) {\n        completedItem = item.then((resolved) =>\n          completeValue(\n            exeContext,\n            itemType,\n            fieldNodes,\n            info,\n            itemPath,\n            resolved,\n          ),\n        );\n      } else {\n        completedItem = completeValue(\n          exeContext,\n          itemType,\n          fieldNodes,\n          info,\n          itemPath,\n          item,\n        );\n      }\n\n      if (isPromise(completedItem)) {\n        containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n        // to take a second callback for the error case.\n\n        return completedItem.then(undefined, (rawError) => {\n          const error = locatedError(\n            rawError,\n            fieldNodes,\n            pathToArray(itemPath),\n          );\n          return handleFieldError(error, itemType, exeContext);\n        });\n      }\n\n      return completedItem;\n    } catch (rawError) {\n      const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n      return handleFieldError(error, itemType, exeContext);\n    }\n  });\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\n\nfunction completeLeafValue(returnType, result) {\n  const serializedResult = returnType.serialize(result);\n\n  if (serializedResult == null) {\n    throw new Error(\n      `Expected \\`${inspect(returnType)}.serialize(${inspect(result)})\\` to ` +\n        `return non-nullable value, returned: ${inspect(serializedResult)}`,\n    );\n  }\n\n  return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\n\nfunction completeAbstractValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  var _returnType$resolveTy;\n\n  const resolveTypeFn =\n    (_returnType$resolveTy = returnType.resolveType) !== null &&\n    _returnType$resolveTy !== void 0\n      ? _returnType$resolveTy\n      : exeContext.typeResolver;\n  const contextValue = exeContext.contextValue;\n  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n\n  if (isPromise(runtimeType)) {\n    return runtimeType.then((resolvedRuntimeType) =>\n      completeObjectValue(\n        exeContext,\n        ensureValidRuntimeType(\n          resolvedRuntimeType,\n          exeContext,\n          returnType,\n          fieldNodes,\n          info,\n          result,\n        ),\n        fieldNodes,\n        info,\n        path,\n        result,\n      ),\n    );\n  }\n\n  return completeObjectValue(\n    exeContext,\n    ensureValidRuntimeType(\n      runtimeType,\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      result,\n    ),\n    fieldNodes,\n    info,\n    path,\n    result,\n  );\n}\n\nfunction ensureValidRuntimeType(\n  runtimeTypeName,\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  result,\n) {\n  if (runtimeTypeName == null) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`,\n      fieldNodes,\n    );\n  } // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\n  // TODO: remove in 17.0.0 release\n\n  if (isObjectType(runtimeTypeName)) {\n    throw new GraphQLError(\n      'Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.',\n    );\n  }\n\n  if (typeof runtimeTypeName !== 'string') {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\" with ` +\n        `value ${inspect(result)}, received \"${inspect(runtimeTypeName)}\".`,\n    );\n  }\n\n  const runtimeType = exeContext.schema.getType(runtimeTypeName);\n\n  if (runtimeType == null) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`,\n      fieldNodes,\n    );\n  }\n\n  if (!isObjectType(runtimeType)) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`,\n      fieldNodes,\n    );\n  }\n\n  if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n    throw new GraphQLError(\n      `Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`,\n      fieldNodes,\n    );\n  }\n\n  return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\n\nfunction completeObjectValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  // Collect sub-fields to execute to complete this value.\n  const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes); // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n\n  if (returnType.isTypeOf) {\n    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n\n    if (isPromise(isTypeOf)) {\n      return isTypeOf.then((resolvedIsTypeOf) => {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n\n        return executeFields(\n          exeContext,\n          returnType,\n          result,\n          path,\n          subFieldNodes,\n        );\n      });\n    }\n\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\n    }\n  }\n\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\n}\n\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n  return new GraphQLError(\n    `Expected value of type \"${returnType.name}\" but got: ${inspect(result)}.`,\n    fieldNodes,\n  );\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\n\nexport const defaultTypeResolver = function (\n  value,\n  contextValue,\n  info,\n  abstractType,\n) {\n  // First, look for `__typename`.\n  if (isObjectLike(value) && typeof value.__typename === 'string') {\n    return value.__typename;\n  } // Otherwise, test each possible type.\n\n  const possibleTypes = info.schema.getPossibleTypes(abstractType);\n  const promisedIsTypeOfResults = [];\n\n  for (let i = 0; i < possibleTypes.length; i++) {\n    const type = possibleTypes[i];\n\n    if (type.isTypeOf) {\n      const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n      if (isPromise(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        return type.name;\n      }\n    }\n  }\n\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {\n      for (let i = 0; i < isTypeOfResults.length; i++) {\n        if (isTypeOfResults[i]) {\n          return possibleTypes[i].name;\n        }\n      }\n    });\n  }\n};\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\n\nexport const defaultFieldResolver = function (\n  source,\n  args,\n  contextValue,\n  info,\n) {\n  // ensure source is a value for which property access is acceptable.\n  if (isObjectLike(source) || typeof source === 'function') {\n    const property = source[info.fieldName];\n\n    if (typeof property === 'function') {\n      return source[info.fieldName](args, contextValue, info);\n    }\n\n    return property;\n  }\n};\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\n\nexport function getFieldDef(schema, parentType, fieldNode) {\n  const fieldName = fieldNode.name.value;\n\n  if (\n    fieldName === SchemaMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return SchemaMetaFieldDef;\n  } else if (\n    fieldName === TypeMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return TypeMetaFieldDef;\n  } else if (fieldName === TypeNameMetaFieldDef.name) {\n    return TypeNameMetaFieldDef;\n  }\n\n  return parentType.getFields()[fieldName];\n}\n"]},"metadata":{},"sourceType":"module"}