{"ast":null,"code":"import _slicedToArray from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { print } from '../language/printer.mjs';\nimport { isEnumType, isInputObjectType, isInterfaceType, isListType, isNamedType, isNonNullType, isObjectType, isRequiredArgument, isRequiredInputField, isScalarType, isUnionType } from '../type/definition.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nimport { sortValueNode } from './sortValueNode.mjs';\nexport var BreakingChangeType;\n\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] = 'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] = 'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] = 'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] = 'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] = 'DIRECTIVE_LOCATION_REMOVED';\n})(BreakingChangeType || (BreakingChangeType = {}));\n\nexport var DangerousChangeType;\n\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] = 'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] = 'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(DangerousChangeType || (DangerousChangeType = {}));\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\n\n\nexport function findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(function (change) {\n    return change.type in BreakingChangeType;\n  });\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(function (change) {\n    return change.type in DangerousChangeType;\n  });\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [].concat(_toConsumableArray(findTypeChanges(oldSchema, newSchema)), _toConsumableArray(findDirectiveChanges(oldSchema, newSchema)));\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  var schemaChanges = [];\n  var directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());\n\n  var _iterator = _createForOfIteratorHelper(directivesDiff.removed),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var oldDirective = _step.value;\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REMOVED,\n        description: \"\".concat(oldDirective.name, \" was removed.\")\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(directivesDiff.persisted),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n          _oldDirective = _step2$value[0],\n          newDirective = _step2$value[1];\n\n      var argsDiff = diff(_oldDirective.args, newDirective.args);\n\n      var _iterator3 = _createForOfIteratorHelper(argsDiff.added),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var newArg = _step3.value;\n\n          if (isRequiredArgument(newArg)) {\n            schemaChanges.push({\n              type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n              description: \"A required arg \".concat(newArg.name, \" on directive \").concat(_oldDirective.name, \" was added.\")\n            });\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(argsDiff.removed),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var oldArg = _step4.value;\n          schemaChanges.push({\n            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n            description: \"\".concat(oldArg.name, \" was removed from \").concat(_oldDirective.name, \".\")\n          });\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      if (_oldDirective.isRepeatable && !newDirective.isRepeatable) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n          description: \"Repeatable flag was removed from \".concat(_oldDirective.name, \".\")\n        });\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(_oldDirective.locations),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var location = _step5.value;\n\n          if (!newDirective.locations.includes(location)) {\n            schemaChanges.push({\n              type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n              description: \"\".concat(location, \" was removed from \").concat(_oldDirective.name, \".\")\n            });\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  var schemaChanges = [];\n  var typesDiff = diff(Object.values(oldSchema.getTypeMap()), Object.values(newSchema.getTypeMap()));\n\n  var _iterator6 = _createForOfIteratorHelper(typesDiff.removed),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var oldType = _step6.value;\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_REMOVED,\n        description: isSpecifiedScalarType(oldType) ? \"Standard scalar \".concat(oldType.name, \" was removed because it is not referenced anymore.\") : \"\".concat(oldType.name, \" was removed.\")\n      });\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  var _iterator7 = _createForOfIteratorHelper(typesDiff.persisted),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var _step7$value = _slicedToArray(_step7.value, 2),\n          _oldType = _step7$value[0],\n          newType = _step7$value[1];\n\n      if (isEnumType(_oldType) && isEnumType(newType)) {\n        schemaChanges.push.apply(schemaChanges, _toConsumableArray(findEnumTypeChanges(_oldType, newType)));\n      } else if (isUnionType(_oldType) && isUnionType(newType)) {\n        schemaChanges.push.apply(schemaChanges, _toConsumableArray(findUnionTypeChanges(_oldType, newType)));\n      } else if (isInputObjectType(_oldType) && isInputObjectType(newType)) {\n        schemaChanges.push.apply(schemaChanges, _toConsumableArray(findInputObjectTypeChanges(_oldType, newType)));\n      } else if (isObjectType(_oldType) && isObjectType(newType)) {\n        schemaChanges.push.apply(schemaChanges, _toConsumableArray(findFieldChanges(_oldType, newType)).concat(_toConsumableArray(findImplementedInterfacesChanges(_oldType, newType))));\n      } else if (isInterfaceType(_oldType) && isInterfaceType(newType)) {\n        schemaChanges.push.apply(schemaChanges, _toConsumableArray(findFieldChanges(_oldType, newType)).concat(_toConsumableArray(findImplementedInterfacesChanges(_oldType, newType))));\n      } else if (_oldType.constructor !== newType.constructor) {\n        schemaChanges.push({\n          type: BreakingChangeType.TYPE_CHANGED_KIND,\n          description: \"\".concat(_oldType.name, \" changed from \") + \"\".concat(typeKindName(_oldType), \" to \").concat(typeKindName(newType), \".\")\n        });\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  var schemaChanges = [];\n  var fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));\n\n  var _iterator8 = _createForOfIteratorHelper(fieldsDiff.added),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var newField = _step8.value;\n\n      if (isRequiredInputField(newField)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n          description: \"A required field \".concat(newField.name, \" on input type \").concat(oldType.name, \" was added.\")\n        });\n      } else {\n        schemaChanges.push({\n          type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n          description: \"An optional field \".concat(newField.name, \" on input type \").concat(oldType.name, \" was added.\")\n        });\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  var _iterator9 = _createForOfIteratorHelper(fieldsDiff.removed),\n      _step9;\n\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var oldField = _step9.value;\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_REMOVED,\n        description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" was removed.\")\n      });\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n\n  var _iterator10 = _createForOfIteratorHelper(fieldsDiff.persisted),\n      _step10;\n\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var _step10$value = _slicedToArray(_step10.value, 2),\n          _oldField = _step10$value[0],\n          _newField = _step10$value[1];\n\n      var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldField.type, _newField.type);\n\n      if (!isSafe) {\n        schemaChanges.push({\n          type: BreakingChangeType.FIELD_CHANGED_KIND,\n          description: \"\".concat(oldType.name, \".\").concat(_oldField.name, \" changed type from \") + \"\".concat(String(_oldField.type), \" to \").concat(String(_newField.type), \".\")\n        });\n      }\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  var schemaChanges = [];\n  var possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  var _iterator11 = _createForOfIteratorHelper(possibleTypesDiff.added),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var newPossibleType = _step11.value;\n      schemaChanges.push({\n        type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n        description: \"\".concat(newPossibleType.name, \" was added to union type \").concat(oldType.name, \".\")\n      });\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  var _iterator12 = _createForOfIteratorHelper(possibleTypesDiff.removed),\n      _step12;\n\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var oldPossibleType = _step12.value;\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n        description: \"\".concat(oldPossibleType.name, \" was removed from union type \").concat(oldType.name, \".\")\n      });\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  var schemaChanges = [];\n  var valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  var _iterator13 = _createForOfIteratorHelper(valuesDiff.added),\n      _step13;\n\n  try {\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      var newValue = _step13.value;\n      schemaChanges.push({\n        type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n        description: \"\".concat(newValue.name, \" was added to enum type \").concat(oldType.name, \".\")\n      });\n    }\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n\n  var _iterator14 = _createForOfIteratorHelper(valuesDiff.removed),\n      _step14;\n\n  try {\n    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n      var oldValue = _step14.value;\n      schemaChanges.push({\n        type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n        description: \"\".concat(oldValue.name, \" was removed from enum type \").concat(oldType.name, \".\")\n      });\n    }\n  } catch (err) {\n    _iterator14.e(err);\n  } finally {\n    _iterator14.f();\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  var schemaChanges = [];\n  var interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  var _iterator15 = _createForOfIteratorHelper(interfacesDiff.added),\n      _step15;\n\n  try {\n    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n      var newInterface = _step15.value;\n      schemaChanges.push({\n        type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n        description: \"\".concat(newInterface.name, \" added to interfaces implemented by \").concat(oldType.name, \".\")\n      });\n    }\n  } catch (err) {\n    _iterator15.e(err);\n  } finally {\n    _iterator15.f();\n  }\n\n  var _iterator16 = _createForOfIteratorHelper(interfacesDiff.removed),\n      _step16;\n\n  try {\n    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n      var oldInterface = _step16.value;\n      schemaChanges.push({\n        type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n        description: \"\".concat(oldType.name, \" no longer implements interface \").concat(oldInterface.name, \".\")\n      });\n    }\n  } catch (err) {\n    _iterator16.e(err);\n  } finally {\n    _iterator16.f();\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  var schemaChanges = [];\n  var fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));\n\n  var _iterator17 = _createForOfIteratorHelper(fieldsDiff.removed),\n      _step17;\n\n  try {\n    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n      var oldField = _step17.value;\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_REMOVED,\n        description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" was removed.\")\n      });\n    }\n  } catch (err) {\n    _iterator17.e(err);\n  } finally {\n    _iterator17.f();\n  }\n\n  var _iterator18 = _createForOfIteratorHelper(fieldsDiff.persisted),\n      _step18;\n\n  try {\n    for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n      var _step18$value = _slicedToArray(_step18.value, 2),\n          _oldField2 = _step18$value[0],\n          newField = _step18$value[1];\n\n      schemaChanges.push.apply(schemaChanges, _toConsumableArray(findArgChanges(oldType, _oldField2, newField)));\n      var isSafe = isChangeSafeForObjectOrInterfaceField(_oldField2.type, newField.type);\n\n      if (!isSafe) {\n        schemaChanges.push({\n          type: BreakingChangeType.FIELD_CHANGED_KIND,\n          description: \"\".concat(oldType.name, \".\").concat(_oldField2.name, \" changed type from \") + \"\".concat(String(_oldField2.type), \" to \").concat(String(newField.type), \".\")\n        });\n      }\n    }\n  } catch (err) {\n    _iterator18.e(err);\n  } finally {\n    _iterator18.f();\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  var schemaChanges = [];\n  var argsDiff = diff(oldField.args, newField.args);\n\n  var _iterator19 = _createForOfIteratorHelper(argsDiff.removed),\n      _step19;\n\n  try {\n    for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n      var oldArg = _step19.value;\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_REMOVED,\n        description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(oldArg.name, \" was removed.\")\n      });\n    }\n  } catch (err) {\n    _iterator19.e(err);\n  } finally {\n    _iterator19.f();\n  }\n\n  var _iterator20 = _createForOfIteratorHelper(argsDiff.persisted),\n      _step20;\n\n  try {\n    for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n      var _step20$value = _slicedToArray(_step20.value, 2),\n          _oldArg = _step20$value[0],\n          newArg = _step20$value[1];\n\n      var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldArg.type, newArg.type);\n\n      if (!isSafe) {\n        schemaChanges.push({\n          type: BreakingChangeType.ARG_CHANGED_KIND,\n          description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(_oldArg.name, \" has changed type from \") + \"\".concat(String(_oldArg.type), \" to \").concat(String(newArg.type), \".\")\n        });\n      } else if (_oldArg.defaultValue !== undefined) {\n        if (newArg.defaultValue === undefined) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(_oldArg.name, \" defaultValue was removed.\")\n          });\n        } else {\n          // Since we looking only for client's observable changes we should\n          // compare default values in the same representation as they are\n          // represented inside introspection.\n          var oldValueStr = stringifyValue(_oldArg.defaultValue, _oldArg.type);\n          var newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n          if (oldValueStr !== newValueStr) {\n            schemaChanges.push({\n              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n              description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(_oldArg.name, \" has changed defaultValue from \").concat(oldValueStr, \" to \").concat(newValueStr, \".\")\n            });\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator20.e(err);\n  } finally {\n    _iterator20.f();\n  }\n\n  var _iterator21 = _createForOfIteratorHelper(argsDiff.added),\n      _step21;\n\n  try {\n    for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n      var _newArg = _step21.value;\n\n      if (isRequiredArgument(_newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_ARG_ADDED,\n          description: \"A required arg \".concat(_newArg.name, \" on \").concat(oldType.name, \".\").concat(oldField.name, \" was added.\")\n        });\n      } else {\n        schemaChanges.push({\n          type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n          description: \"An optional arg \".concat(_newArg.name, \" on \").concat(oldType.name, \".\").concat(oldField.name, \" was added.\")\n        });\n      }\n    }\n  } catch (err) {\n    _iterator21.e(err);\n  } finally {\n    _iterator21.f();\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isListType(oldType)) {\n    return (// if they're both lists, make sure the underlying types are compatible\n      isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n\n  return (// if they're both named types, see if their names are equivalent\n    isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe\n    isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  }\n\n  if (isNonNullType(oldType)) {\n    return (// if they're both non-null, make sure the underlying types are\n      // compatible\n      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe\n      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  } // if they're both named types, see if their names are equivalent\n\n\n  return isNamedType(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction stringifyValue(value, type) {\n  var ast = astFromValue(value, type);\n  ast != null || invariant(false);\n  return print(sortValueNode(ast));\n}\n\nfunction diff(oldArray, newArray) {\n  var added = [];\n  var removed = [];\n  var persisted = [];\n  var oldMap = keyMap(oldArray, function (_ref) {\n    var name = _ref.name;\n    return name;\n  });\n  var newMap = keyMap(newArray, function (_ref2) {\n    var name = _ref2.name;\n    return name;\n  });\n\n  var _iterator22 = _createForOfIteratorHelper(oldArray),\n      _step22;\n\n  try {\n    for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n      var oldItem = _step22.value;\n      var newItem = newMap[oldItem.name];\n\n      if (newItem === undefined) {\n        removed.push(oldItem);\n      } else {\n        persisted.push([oldItem, newItem]);\n      }\n    }\n  } catch (err) {\n    _iterator22.e(err);\n  } finally {\n    _iterator22.f();\n  }\n\n  var _iterator23 = _createForOfIteratorHelper(newArray),\n      _step23;\n\n  try {\n    for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n      var _newItem = _step23.value;\n\n      if (oldMap[_newItem.name] === undefined) {\n        added.push(_newItem);\n      }\n    }\n  } catch (err) {\n    _iterator23.e(err);\n  } finally {\n    _iterator23.f();\n  }\n\n  return {\n    added: added,\n    persisted: persisted,\n    removed: removed\n  };\n}","map":{"version":3,"sources":["C:/Users/GATHU/Desktop/node_modules/graphql/utilities/findBreakingChanges.mjs"],"names":["inspect","invariant","keyMap","print","isEnumType","isInputObjectType","isInterfaceType","isListType","isNamedType","isNonNullType","isObjectType","isRequiredArgument","isRequiredInputField","isScalarType","isUnionType","isSpecifiedScalarType","astFromValue","sortValueNode","BreakingChangeType","DangerousChangeType","findBreakingChanges","oldSchema","newSchema","findSchemaChanges","filter","change","type","findDangerousChanges","findTypeChanges","findDirectiveChanges","schemaChanges","directivesDiff","diff","getDirectives","removed","oldDirective","push","DIRECTIVE_REMOVED","description","name","persisted","newDirective","argsDiff","args","added","newArg","REQUIRED_DIRECTIVE_ARG_ADDED","oldArg","DIRECTIVE_ARG_REMOVED","isRepeatable","DIRECTIVE_REPEATABLE_REMOVED","locations","location","includes","DIRECTIVE_LOCATION_REMOVED","typesDiff","Object","values","getTypeMap","oldType","TYPE_REMOVED","newType","findEnumTypeChanges","findUnionTypeChanges","findInputObjectTypeChanges","findFieldChanges","findImplementedInterfacesChanges","constructor","TYPE_CHANGED_KIND","typeKindName","fieldsDiff","getFields","newField","REQUIRED_INPUT_FIELD_ADDED","OPTIONAL_INPUT_FIELD_ADDED","oldField","FIELD_REMOVED","isSafe","isChangeSafeForInputObjectFieldOrFieldArg","FIELD_CHANGED_KIND","String","possibleTypesDiff","getTypes","newPossibleType","TYPE_ADDED_TO_UNION","oldPossibleType","TYPE_REMOVED_FROM_UNION","valuesDiff","getValues","newValue","VALUE_ADDED_TO_ENUM","oldValue","VALUE_REMOVED_FROM_ENUM","interfacesDiff","getInterfaces","newInterface","IMPLEMENTED_INTERFACE_ADDED","oldInterface","IMPLEMENTED_INTERFACE_REMOVED","findArgChanges","isChangeSafeForObjectOrInterfaceField","ARG_REMOVED","ARG_CHANGED_KIND","defaultValue","undefined","ARG_DEFAULT_VALUE_CHANGE","oldValueStr","stringifyValue","newValueStr","REQUIRED_ARG_ADDED","OPTIONAL_ARG_ADDED","ofType","value","ast","oldArray","newArray","oldMap","newMap","oldItem","newItem"],"mappings":"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","sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { print } from '../language/printer.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isRequiredArgument,\n  isRequiredInputField,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nimport { sortValueNode } from './sortValueNode.mjs';\nexport let BreakingChangeType;\n\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] =\n    'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] =\n    'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] =\n    'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] =\n    'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] =\n    'DIRECTIVE_LOCATION_REMOVED';\n})(BreakingChangeType || (BreakingChangeType = {}));\n\nexport let DangerousChangeType;\n\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] =\n    'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] =\n    'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(DangerousChangeType || (DangerousChangeType = {}));\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in BreakingChangeType,\n  );\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in DangerousChangeType,\n  );\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [\n    ...findTypeChanges(oldSchema, newSchema),\n    ...findDirectiveChanges(oldSchema, newSchema),\n  ];\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const directivesDiff = diff(\n    oldSchema.getDirectives(),\n    newSchema.getDirectives(),\n  );\n\n  for (const oldDirective of directivesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: `${oldDirective.name} was removed.`,\n    });\n  }\n\n  for (const [oldDirective, newDirective] of directivesDiff.persisted) {\n    const argsDiff = diff(oldDirective.args, newDirective.args);\n\n    for (const newArg of argsDiff.added) {\n      if (isRequiredArgument(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`,\n        });\n      }\n    }\n\n    for (const oldArg of argsDiff.removed) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: `${oldArg.name} was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: `Repeatable flag was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    for (const location of oldDirective.locations) {\n      if (!newDirective.locations.includes(location)) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: `${location} was removed from ${oldDirective.name}.`,\n        });\n      }\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const typesDiff = diff(\n    Object.values(oldSchema.getTypeMap()),\n    Object.values(newSchema.getTypeMap()),\n  );\n\n  for (const oldType of typesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: isSpecifiedScalarType(oldType)\n        ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.`\n        : `${oldType.name} was removed.`,\n    });\n  }\n\n  for (const [oldType, newType] of typesDiff.persisted) {\n    if (isEnumType(oldType) && isEnumType(newType)) {\n      schemaChanges.push(...findEnumTypeChanges(oldType, newType));\n    } else if (isUnionType(oldType) && isUnionType(newType)) {\n      schemaChanges.push(...findUnionTypeChanges(oldType, newType));\n    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {\n      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));\n    } else if (isObjectType(oldType) && isObjectType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description:\n          `${oldType.name} changed from ` +\n          `${typeKindName(oldType)} to ${typeKindName(newType)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const newField of fieldsDiff.added) {\n    if (isRequiredInputField(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: `A required field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    }\n  }\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  for (const newPossibleType of possibleTypesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: `${newPossibleType.name} was added to union type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldPossibleType of possibleTypesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  for (const newValue of valuesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: `${newValue.name} was added to enum type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldValue of valuesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: `${oldValue.name} was removed from enum type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  const schemaChanges = [];\n  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  for (const newInterface of interfacesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`,\n    });\n  }\n\n  for (const oldInterface of interfacesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    schemaChanges.push(...findArgChanges(oldType, oldField, newField));\n    const isSafe = isChangeSafeForObjectOrInterfaceField(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  const schemaChanges = [];\n  const argsDiff = diff(oldField.args, newField.args);\n\n  for (const oldArg of argsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`,\n    });\n  }\n\n  for (const [oldArg, newArg] of argsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldArg.type,\n      newArg.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` +\n          `${String(oldArg.type)} to ${String(newArg.type)}.`,\n      });\n    } else if (oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`,\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);\n        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`,\n          });\n        }\n      }\n    }\n  }\n\n  for (const newArg of argsDiff.added) {\n    if (isRequiredArgument(newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isListType(oldType)) {\n    return (\n      // if they're both lists, make sure the underlying types are compatible\n      (isListType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from nullable to non-null of the same underlying type is safe\n      (isNonNullType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return (\n      isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType)\n    );\n  }\n\n  return (\n    // if they're both named types, see if their names are equivalent\n    (isNamedType(newType) && oldType.name === newType.name) || // moving from nullable to non-null of the same underlying type is safe\n    (isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return (\n      isListType(newType) &&\n      isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType)\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    return (\n      // if they're both non-null, make sure the underlying types are\n      // compatible\n      (isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from non-null to nullable of the same underlying type is safe\n      (!isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType))\n    );\n  } // if they're both named types, see if their names are equivalent\n\n  return isNamedType(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction stringifyValue(value, type) {\n  const ast = astFromValue(value, type);\n  ast != null || invariant(false);\n  return print(sortValueNode(ast));\n}\n\nfunction diff(oldArray, newArray) {\n  const added = [];\n  const removed = [];\n  const persisted = [];\n  const oldMap = keyMap(oldArray, ({ name }) => name);\n  const newMap = keyMap(newArray, ({ name }) => name);\n\n  for (const oldItem of oldArray) {\n    const newItem = newMap[oldItem.name];\n\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n\n  for (const newItem of newArray) {\n    if (oldMap[newItem.name] === undefined) {\n      added.push(newItem);\n    }\n  }\n\n  return {\n    added,\n    persisted,\n    removed,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}