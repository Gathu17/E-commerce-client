{"ast":null,"code":"import _classCallCheck from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _toConsumableArray from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { getNamedType, isInterfaceType, isLeafType, isListType, isNonNullType, isObjectType } from '../../type/definition.mjs';\nimport { sortValueNode } from '../../utilities/sortValueNode.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          responseName = _ref2[0],\n          subReason = _ref2[1];\n\n      return \"subfields \\\"\".concat(responseName, \"\\\" conflict because \") + reasonMessage(subReason);\n    }).join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\n\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  var cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n\n      var _iterator = _createForOfIteratorHelper(conflicts),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 3),\n              _step$value$ = _slicedToArray(_step$value[0], 2),\n              responseName = _step$value$[0],\n              reason = _step$value$[1],\n              fields1 = _step$value[1],\n              fields2 = _step$value[2];\n\n          var reasonMsg = reasonMessage(reason);\n          context.reportError(new GraphQLError(\"Fields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMsg, \". Use different aliases on the fields to fetch both if this was intentional.\"), fields1.concat(fields2)));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  };\n}\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\n\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n      _getFieldsAndFragment2 = _slicedToArray(_getFieldsAndFragment, 2),\n      fieldMap = _getFieldsAndFragment2[0],\n      fragmentNames = _getFieldsAndFragment2[1]; // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (var i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (var j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  var fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n      _getReferencedFieldsA2 = _slicedToArray(_getReferencedFieldsA, 2),\n      fieldMap2 = _getReferencedFieldsA2[0],\n      referencedFragmentNames = _getReferencedFieldsA2[1]; // Do not compare a fragment's fieldMap to itself.\n\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  var _iterator2 = _createForOfIteratorHelper(referencedFragmentNames),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var referencedFragmentName = _step2.value;\n\n      // Memoize so two fragments are not compared for conflicts more than once.\n      if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {\n        continue;\n      }\n\n      comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n      _getReferencedFieldsA4 = _slicedToArray(_getReferencedFieldsA3, 2),\n      fieldMap1 = _getReferencedFieldsA4[0],\n      referencedFragmentNames1 = _getReferencedFieldsA4[1];\n\n  var _getReferencedFieldsA5 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n      _getReferencedFieldsA6 = _slicedToArray(_getReferencedFieldsA5, 2),\n      fieldMap2 = _getReferencedFieldsA6[0],\n      referencedFragmentNames2 = _getReferencedFieldsA6[1]; // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  var _iterator3 = _createForOfIteratorHelper(referencedFragmentNames2),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var referencedFragmentName2 = _step3.value;\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);\n    } // (G) Then collect conflicts between the second fragment and any nested\n    // fragments spread in the first fragment.\n\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  var _iterator4 = _createForOfIteratorHelper(referencedFragmentNames1),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var referencedFragmentName1 = _step4.value;\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n      _getFieldsAndFragment4 = _slicedToArray(_getFieldsAndFragment3, 2),\n      fieldMap1 = _getFieldsAndFragment4[0],\n      fragmentNames1 = _getFieldsAndFragment4[1];\n\n  var _getFieldsAndFragment5 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n      _getFieldsAndFragment6 = _slicedToArray(_getFieldsAndFragment5, 2),\n      fieldMap2 = _getFieldsAndFragment6[0],\n      fragmentNames2 = _getFieldsAndFragment6[1]; // (H) First, collect all conflicts between these two collections of field.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  var _iterator5 = _createForOfIteratorHelper(fragmentNames2),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var fragmentName2 = _step5.value;\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);\n    } // (I) Then collect conflicts between the second collection of fields and\n    // those referenced by each fragment name associated with the first.\n\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  var _iterator6 = _createForOfIteratorHelper(fragmentNames1),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var fragmentName1 = _step6.value;\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);\n    } // (J) Also collect conflicts between any fragment names by the first and\n    // fragment names by the second. This compares each item in the first set of\n    // names to each item in the second set of names.\n\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  var _iterator7 = _createForOfIteratorHelper(fragmentNames1),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var _fragmentName = _step7.value;\n\n      var _iterator8 = _createForOfIteratorHelper(fragmentNames2),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _fragmentName2 = _step8.value;\n          collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, _fragmentName, _fragmentName2);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (var _i = 0, _Object$entries = Object.entries(fieldMap); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        responseName = _Object$entries$_i[0],\n        fields = _Object$entries$_i[1];\n\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (var _i2 = 0, _Object$entries2 = Object.entries(fieldMap1); _i2 < _Object$entries2.length; _i2++) {\n    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n        responseName = _Object$entries2$_i[0],\n        fields1 = _Object$entries2$_i[1];\n\n    var fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      var _iterator9 = _createForOfIteratorHelper(fields1),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var field1 = _step9.value;\n\n          var _iterator10 = _createForOfIteratorHelper(fields2),\n              _step10;\n\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var field2 = _step10.value;\n              var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);\n\n              if (conflict) {\n                conflicts.push(conflict);\n              }\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var _field = _slicedToArray(field1, 3),\n      parentType1 = _field[0],\n      node1 = _field[1],\n      def1 = _field[2];\n\n  var _field2 = _slicedToArray(field2, 3),\n      parentType2 = _field2[0],\n      node2 = _field2[1],\n      def2 = _field2[2]; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [[responseName, \"\\\"\".concat(name1, \"\\\" and \\\"\").concat(name2, \"\\\" are different fields\")], [node1], [node2]];\n    } // Two field calls must have the same arguments.\n\n\n    if (stringifyArguments(node1) !== stringifyArguments(node2)) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  } // The return type for each field.\n\n\n  var type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  var type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, \"they return conflicting types \\\"\".concat(inspect(type1), \"\\\" and \\\"\").concat(inspect(type2), \"\\\"\")], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction stringifyArguments(fieldNode) {\n  var _fieldNode$arguments; // FIXME https://github.com/graphql/graphql-js/issues/2203\n\n\n  var args =\n  /* c8 ignore next */\n  (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];\n  var inputObjectWithArgs = {\n    kind: Kind.OBJECT,\n    fields: args.map(function (argNode) {\n      return {\n        kind: Kind.OBJECT_FIELD,\n        name: argNode.name,\n        value: argNode.value\n      };\n    })\n  };\n  return print(sortValueNode(inputObjectWithArgs));\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  var nodeAndDefs = Object.create(null);\n  var fragmentNames = Object.create(null);\n\n  _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n\n  var result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  var fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  var _iterator11 = _createForOfIteratorHelper(selectionSet.selections),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var selection = _step11.value;\n\n      switch (selection.kind) {\n        case Kind.FIELD:\n          {\n            var fieldName = selection.name.value;\n            var fieldDef = void 0;\n\n            if (isObjectType(parentType) || isInterfaceType(parentType)) {\n              fieldDef = parentType.getFields()[fieldName];\n            }\n\n            var responseName = selection.alias ? selection.alias.value : fieldName;\n\n            if (!nodeAndDefs[responseName]) {\n              nodeAndDefs[responseName] = [];\n            }\n\n            nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n            break;\n          }\n\n        case Kind.FRAGMENT_SPREAD:\n          fragmentNames[selection.name.value] = true;\n          break;\n\n        case Kind.INLINE_FRAGMENT:\n          {\n            var typeCondition = selection.typeCondition;\n            var inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\n\n            _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n\n            break;\n          }\n      }\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 1),\n          reason = _ref4[0];\n\n      return reason;\n    })], [node1].concat(_toConsumableArray(conflicts.map(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n          fields1 = _ref6[1];\n\n      return fields1;\n    }).flat())), [node2].concat(_toConsumableArray(conflicts.map(function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 3),\n          fields2 = _ref8[2];\n\n      return fields2;\n    }).flat()))];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does not matter.\n */\n\n\nvar PairSet = /*#__PURE__*/function () {\n  function PairSet() {\n    _classCallCheck(this, PairSet);\n\n    this._data = new Map();\n  }\n\n  _createClass(PairSet, [{\n    key: \"has\",\n    value: function has(a, b, areMutuallyExclusive) {\n      var _this$_data$get;\n\n      var _ref9 = a < b ? [a, b] : [b, a],\n          _ref10 = _slicedToArray(_ref9, 2),\n          key1 = _ref10[0],\n          key2 = _ref10[1];\n\n      var result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);\n\n      if (result === undefined) {\n        return false;\n      } // areMutuallyExclusive being false is a superset of being true, hence if\n      // we want to know if this PairSet \"has\" these two with no exclusivity,\n      // we have to ensure it was added as such.\n\n\n      return areMutuallyExclusive ? true : areMutuallyExclusive === result;\n    }\n  }, {\n    key: \"add\",\n    value: function add(a, b, areMutuallyExclusive) {\n      var _ref11 = a < b ? [a, b] : [b, a],\n          _ref12 = _slicedToArray(_ref11, 2),\n          key1 = _ref12[0],\n          key2 = _ref12[1];\n\n      var map = this._data.get(key1);\n\n      if (map === undefined) {\n        this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));\n      } else {\n        map.set(key2, areMutuallyExclusive);\n      }\n    }\n  }]);\n\n  return PairSet;\n}();","map":{"version":3,"sources":["C:/Users/GATHU/Desktop/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs"],"names":["inspect","GraphQLError","Kind","print","getNamedType","isInterfaceType","isLeafType","isListType","isNonNullType","isObjectType","sortValueNode","typeFromAST","reasonMessage","reason","Array","isArray","map","responseName","subReason","join","OverlappingFieldsCanBeMergedRule","context","comparedFragmentPairs","PairSet","cachedFieldsAndFragmentNames","Map","SelectionSet","selectionSet","conflicts","findConflictsWithinSelectionSet","getParentType","fields1","fields2","reasonMsg","reportError","concat","parentType","getFieldsAndFragmentNames","fieldMap","fragmentNames","collectConflictsWithin","length","i","collectConflictsBetweenFieldsAndFragment","j","collectConflictsBetweenFragments","areMutuallyExclusive","fragmentName","fragment","getFragment","getReferencedFieldsAndFragmentNames","fieldMap2","referencedFragmentNames","collectConflictsBetween","referencedFragmentName","has","add","fragmentName1","fragmentName2","fragment1","fragment2","fieldMap1","referencedFragmentNames1","referencedFragmentNames2","referencedFragmentName2","referencedFragmentName1","findConflictsBetweenSubSelectionSets","parentType1","selectionSet1","parentType2","selectionSet2","fragmentNames1","fragmentNames2","Object","entries","fields","conflict","findConflict","push","parentFieldsAreMutuallyExclusive","field1","field2","node1","def1","node2","def2","name1","name","value","name2","stringifyArguments","type1","type","type2","doTypesConflict","subfieldConflicts","fieldNode","_fieldNode$arguments","args","arguments","inputObjectWithArgs","kind","OBJECT","argNode","OBJECT_FIELD","ofType","cached","get","nodeAndDefs","create","_collectFieldsAndFragmentNames","result","keys","set","fragmentType","getSchema","typeCondition","selections","selection","FIELD","fieldName","fieldDef","getFields","alias","FRAGMENT_SPREAD","INLINE_FRAGMENT","inlineFragmentType","flat","_data","a","b","_this$_data$get","key1","key2","undefined"],"mappings":";;;;;AAAA,SAASA,OAAT,QAAwB,2BAAxB;AACA,SAASC,YAAT,QAA6B,8BAA7B;AACA,SAASC,IAAT,QAAqB,0BAArB;AACA,SAASC,KAAT,QAAsB,4BAAtB;AACA,SACEC,YADF,EAEEC,eAFF,EAGEC,UAHF,EAIEC,UAJF,EAKEC,aALF,EAMEC,YANF,QAOO,2BAPP;AAQA,SAASC,aAAT,QAA8B,mCAA9B;AACA,SAASC,WAAT,QAA4B,iCAA5B;;AAEA,SAASC,aAAT,CAAuBC,MAAvB,EAA+B;AAC7B,MAAIC,KAAK,CAACC,OAAN,CAAcF,MAAd,CAAJ,EAA2B;AACzB,WAAOA,MAAM,CACVG,GADI,CAEH;AAAA;AAAA,UAAEC,YAAF;AAAA,UAAgBC,SAAhB;;AAAA,aACE,sBAAcD,YAAd,4BACAL,aAAa,CAACM,SAAD,CAFf;AAAA,KAFG,EAMJC,IANI,CAMC,OAND,CAAP;AAOD;;AAED,SAAON,MAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,OAAO,SAASO,gCAAT,CAA0CC,OAA1C,EAAmD;AACxD;AACA;AACA;AACA,MAAMC,qBAAqB,GAAG,IAAIC,OAAJ,EAA9B,CAJwD,CAIX;AAC7C;AACA;;AAEA,MAAMC,4BAA4B,GAAG,IAAIC,GAAJ,EAArC;AACA,SAAO;AACLC,IAAAA,YADK,wBACQC,YADR,EACsB;AACzB,UAAMC,SAAS,GAAGC,+BAA+B,CAC/CR,OAD+C,EAE/CG,4BAF+C,EAG/CF,qBAH+C,EAI/CD,OAAO,CAACS,aAAR,EAJ+C,EAK/CH,YAL+C,CAAjD;;AADyB,iDASgCC,SAThC;AAAA;;AAAA;AASzB,4DAAoE;AAAA;AAAA;AAAA,cAAvDX,YAAuD;AAAA,cAAzCJ,MAAyC;AAAA,cAAhCkB,OAAgC;AAAA,cAAvBC,OAAuB;;AAClE,cAAMC,SAAS,GAAGrB,aAAa,CAACC,MAAD,CAA/B;AACAQ,UAAAA,OAAO,CAACa,WAAR,CACE,IAAIjC,YAAJ,oBACagB,YADb,iCAC+CgB,SAD/C,mFAEEF,OAAO,CAACI,MAAR,CAAeH,OAAf,CAFF,CADF;AAMD;AAjBwB;AAAA;AAAA;AAAA;AAAA;AAkB1B;AAnBI,GAAP;AAqBD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASH,+BAAT,CACER,OADF,EAEEG,4BAFF,EAGEF,qBAHF,EAIEc,UAJF,EAKET,YALF,EAME;AACA,MAAMC,SAAS,GAAG,EAAlB;;AACA,8BAAkCS,yBAAyB,CACzDhB,OADyD,EAEzDG,4BAFyD,EAGzDY,UAHyD,EAIzDT,YAJyD,CAA3D;AAAA;AAAA,MAAOW,QAAP;AAAA,MAAiBC,aAAjB,6BAFA,CAOG;AACH;;;AAEAC,EAAAA,sBAAsB,CACpBnB,OADoB,EAEpBO,SAFoB,EAGpBJ,4BAHoB,EAIpBF,qBAJoB,EAKpBgB,QALoB,CAAtB;;AAQA,MAAIC,aAAa,CAACE,MAAd,KAAyB,CAA7B,EAAgC;AAC9B;AACA;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,aAAa,CAACE,MAAlC,EAA0CC,CAAC,EAA3C,EAA+C;AAC7CC,MAAAA,wCAAwC,CACtCtB,OADsC,EAEtCO,SAFsC,EAGtCJ,4BAHsC,EAItCF,qBAJsC,EAKtC,KALsC,EAMtCgB,QANsC,EAOtCC,aAAa,CAACG,CAAD,CAPyB,CAAxC,CAD6C,CAS1C;AACH;AACA;AACA;;AAEA,WAAK,IAAIE,CAAC,GAAGF,CAAC,GAAG,CAAjB,EAAoBE,CAAC,GAAGL,aAAa,CAACE,MAAtC,EAA8CG,CAAC,EAA/C,EAAmD;AACjDC,QAAAA,gCAAgC,CAC9BxB,OAD8B,EAE9BO,SAF8B,EAG9BJ,4BAH8B,EAI9BF,qBAJ8B,EAK9B,KAL8B,EAM9BiB,aAAa,CAACG,CAAD,CANiB,EAO9BH,aAAa,CAACK,CAAD,CAPiB,CAAhC;AASD;AACF;AACF;;AAED,SAAOhB,SAAP;AACD,C,CAAC;AACF;;;AAEA,SAASe,wCAAT,CACEtB,OADF,EAEEO,SAFF,EAGEJ,4BAHF,EAIEF,qBAJF,EAKEwB,oBALF,EAMER,QANF,EAOES,YAPF,EAQE;AACA,MAAMC,QAAQ,GAAG3B,OAAO,CAAC4B,WAAR,CAAoBF,YAApB,CAAjB;;AAEA,MAAI,CAACC,QAAL,EAAe;AACb;AACD;;AAED,8BACEE,mCAAmC,CACjC7B,OADiC,EAEjCG,4BAFiC,EAGjCwB,QAHiC,CADrC;AAAA;AAAA,MAAOG,SAAP;AAAA,MAAkBC,uBAAlB,6BAPA,CAYK;;;AAEL,MAAId,QAAQ,KAAKa,SAAjB,EAA4B;AAC1B;AACD,GAhBD,CAgBE;AACF;;;AAEAE,EAAAA,uBAAuB,CACrBhC,OADqB,EAErBO,SAFqB,EAGrBJ,4BAHqB,EAIrBF,qBAJqB,EAKrBwB,oBALqB,EAMrBR,QANqB,EAOrBa,SAPqB,CAAvB,CAnBA,CA2BG;AACH;;AA5BA,8CA8BqCC,uBA9BrC;AAAA;;AAAA;AA8BA,2DAA8D;AAAA,UAAnDE,sBAAmD;;AAC5D;AACA,UACEhC,qBAAqB,CAACiC,GAAtB,CACED,sBADF,EAEEP,YAFF,EAGED,oBAHF,CADF,EAME;AACA;AACD;;AAEDxB,MAAAA,qBAAqB,CAACkC,GAAtB,CACEF,sBADF,EAEEP,YAFF,EAGED,oBAHF;AAKAH,MAAAA,wCAAwC,CACtCtB,OADsC,EAEtCO,SAFsC,EAGtCJ,4BAHsC,EAItCF,qBAJsC,EAKtCwB,oBALsC,EAMtCR,QANsC,EAOtCgB,sBAPsC,CAAxC;AASD;AAxDD;AAAA;AAAA;AAAA;AAAA;AAyDD,C,CAAC;AACF;;;AAEA,SAAST,gCAAT,CACExB,OADF,EAEEO,SAFF,EAGEJ,4BAHF,EAIEF,qBAJF,EAKEwB,oBALF,EAMEW,aANF,EAOEC,aAPF,EAQE;AACA;AACA,MAAID,aAAa,KAAKC,aAAtB,EAAqC;AACnC;AACD,GAJD,CAIE;;;AAEF,MACEpC,qBAAqB,CAACiC,GAAtB,CACEE,aADF,EAEEC,aAFF,EAGEZ,oBAHF,CADF,EAME;AACA;AACD;;AAEDxB,EAAAA,qBAAqB,CAACkC,GAAtB,CAA0BC,aAA1B,EAAyCC,aAAzC,EAAwDZ,oBAAxD;AACA,MAAMa,SAAS,GAAGtC,OAAO,CAAC4B,WAAR,CAAoBQ,aAApB,CAAlB;AACA,MAAMG,SAAS,GAAGvC,OAAO,CAAC4B,WAAR,CAAoBS,aAApB,CAAlB;;AAEA,MAAI,CAACC,SAAD,IAAc,CAACC,SAAnB,EAA8B;AAC5B;AACD;;AAED,+BACEV,mCAAmC,CACjC7B,OADiC,EAEjCG,4BAFiC,EAGjCmC,SAHiC,CADrC;AAAA;AAAA,MAAOE,SAAP;AAAA,MAAkBC,wBAAlB;;AAMA,+BACEZ,mCAAmC,CACjC7B,OADiC,EAEjCG,4BAFiC,EAGjCoC,SAHiC,CADrC;AAAA;AAAA,MAAOT,SAAP;AAAA,MAAkBY,wBAAlB,6BA9BA,CAmCK;AACL;;;AAEAV,EAAAA,uBAAuB,CACrBhC,OADqB,EAErBO,SAFqB,EAGrBJ,4BAHqB,EAIrBF,qBAJqB,EAKrBwB,oBALqB,EAMrBe,SANqB,EAOrBV,SAPqB,CAAvB,CAtCA,CA8CG;AACH;;AA/CA,8CAiDsCY,wBAjDtC;AAAA;;AAAA;AAiDA,2DAAgE;AAAA,UAArDC,uBAAqD;AAC9DnB,MAAAA,gCAAgC,CAC9BxB,OAD8B,EAE9BO,SAF8B,EAG9BJ,4BAH8B,EAI9BF,qBAJ8B,EAK9BwB,oBAL8B,EAM9BW,aAN8B,EAO9BO,uBAP8B,CAAhC;AASD,KA3DD,CA2DE;AACF;;AA5DA;AAAA;AAAA;AAAA;AAAA;;AAAA,8CA8DsCF,wBA9DtC;AAAA;;AAAA;AA8DA,2DAAgE;AAAA,UAArDG,uBAAqD;AAC9DpB,MAAAA,gCAAgC,CAC9BxB,OAD8B,EAE9BO,SAF8B,EAG9BJ,4BAH8B,EAI9BF,qBAJ8B,EAK9BwB,oBAL8B,EAM9BmB,uBAN8B,EAO9BP,aAP8B,CAAhC;AASD;AAxED;AAAA;AAAA;AAAA;AAAA;AAyED,C,CAAC;AACF;AACA;;;AAEA,SAASQ,oCAAT,CACE7C,OADF,EAEEG,4BAFF,EAGEF,qBAHF,EAIEwB,oBAJF,EAKEqB,WALF,EAMEC,aANF,EAOEC,WAPF,EAQEC,aARF,EASE;AACA,MAAM1C,SAAS,GAAG,EAAlB;;AACA,+BAAoCS,yBAAyB,CAC3DhB,OAD2D,EAE3DG,4BAF2D,EAG3D2C,WAH2D,EAI3DC,aAJ2D,CAA7D;AAAA;AAAA,MAAOP,SAAP;AAAA,MAAkBU,cAAlB;;AAMA,+BAAoClC,yBAAyB,CAC3DhB,OAD2D,EAE3DG,4BAF2D,EAG3D6C,WAH2D,EAI3DC,aAJ2D,CAA7D;AAAA;AAAA,MAAOnB,SAAP;AAAA,MAAkBqB,cAAlB,6BARA,CAaG;;;AAEHnB,EAAAA,uBAAuB,CACrBhC,OADqB,EAErBO,SAFqB,EAGrBJ,4BAHqB,EAIrBF,qBAJqB,EAKrBwB,oBALqB,EAMrBe,SANqB,EAOrBV,SAPqB,CAAvB,CAfA,CAuBG;AACH;;AAxBA,8CA0B4BqB,cA1B5B;AAAA;;AAAA;AA0BA,2DAA4C;AAAA,UAAjCd,aAAiC;AAC1Cf,MAAAA,wCAAwC,CACtCtB,OADsC,EAEtCO,SAFsC,EAGtCJ,4BAHsC,EAItCF,qBAJsC,EAKtCwB,oBALsC,EAMtCe,SANsC,EAOtCH,aAPsC,CAAxC;AASD,KApCD,CAoCE;AACF;;AArCA;AAAA;AAAA;AAAA;AAAA;;AAAA,8CAuC4Ba,cAvC5B;AAAA;;AAAA;AAuCA,2DAA4C;AAAA,UAAjCd,aAAiC;AAC1Cd,MAAAA,wCAAwC,CACtCtB,OADsC,EAEtCO,SAFsC,EAGtCJ,4BAHsC,EAItCF,qBAJsC,EAKtCwB,oBALsC,EAMtCK,SANsC,EAOtCM,aAPsC,CAAxC;AASD,KAjDD,CAiDE;AACF;AACA;;AAnDA;AAAA;AAAA;AAAA;AAAA;;AAAA,8CAqD4Bc,cArD5B;AAAA;;AAAA;AAqDA,2DAA4C;AAAA,UAAjCd,aAAiC;;AAAA,kDACde,cADc;AAAA;;AAAA;AAC1C,+DAA4C;AAAA,cAAjCd,cAAiC;AAC1Cb,UAAAA,gCAAgC,CAC9BxB,OAD8B,EAE9BO,SAF8B,EAG9BJ,4BAH8B,EAI9BF,qBAJ8B,EAK9BwB,oBAL8B,EAM9BW,aAN8B,EAO9BC,cAP8B,CAAhC;AASD;AAXyC;AAAA;AAAA;AAAA;AAAA;AAY3C;AAjED;AAAA;AAAA;AAAA;AAAA;;AAmEA,SAAO9B,SAAP;AACD,C,CAAC;;;AAEF,SAASY,sBAAT,CACEnB,OADF,EAEEO,SAFF,EAGEJ,4BAHF,EAIEF,qBAJF,EAKEgB,QALF,EAME;AACA;AACA;AACA;AACA;AACA,qCAAqCmC,MAAM,CAACC,OAAP,CAAepC,QAAf,CAArC,qCAA+D;AAA1D;AAAA,QAAOrB,YAAP;AAAA,QAAqB0D,MAArB;;AACH;AACA;AACA;AACA,QAAIA,MAAM,CAAClC,MAAP,GAAgB,CAApB,EAAuB;AACrB,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiC,MAAM,CAAClC,MAA3B,EAAmCC,CAAC,EAApC,EAAwC;AACtC,aAAK,IAAIE,CAAC,GAAGF,CAAC,GAAG,CAAjB,EAAoBE,CAAC,GAAG+B,MAAM,CAAClC,MAA/B,EAAuCG,CAAC,EAAxC,EAA4C;AAC1C,cAAMgC,QAAQ,GAAGC,YAAY,CAC3BxD,OAD2B,EAE3BG,4BAF2B,EAG3BF,qBAH2B,EAI3B,KAJ2B,EAIpB;AACPL,UAAAA,YAL2B,EAM3B0D,MAAM,CAACjC,CAAD,CANqB,EAO3BiC,MAAM,CAAC/B,CAAD,CAPqB,CAA7B;;AAUA,cAAIgC,QAAJ,EAAc;AACZhD,YAAAA,SAAS,CAACkD,IAAV,CAAeF,QAAf;AACD;AACF;AACF;AACF;AACF;AACF,C,CAAC;AACF;AACA;AACA;AACA;;;AAEA,SAASvB,uBAAT,CACEhC,OADF,EAEEO,SAFF,EAGEJ,4BAHF,EAIEF,qBAJF,EAKEyD,gCALF,EAMElB,SANF,EAOEV,SAPF,EAQE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsCsB,MAAM,CAACC,OAAP,CAAeb,SAAf,CAAtC,wCAAiE;AAA5D;AAAA,QAAO5C,YAAP;AAAA,QAAqBc,OAArB;;AACH,QAAMC,OAAO,GAAGmB,SAAS,CAAClC,YAAD,CAAzB;;AAEA,QAAIe,OAAJ,EAAa;AAAA,kDACUD,OADV;AAAA;;AAAA;AACX,+DAA8B;AAAA,cAAnBiD,MAAmB;;AAAA,uDACPhD,OADO;AAAA;;AAAA;AAC5B,sEAA8B;AAAA,kBAAnBiD,MAAmB;AAC5B,kBAAML,QAAQ,GAAGC,YAAY,CAC3BxD,OAD2B,EAE3BG,4BAF2B,EAG3BF,qBAH2B,EAI3ByD,gCAJ2B,EAK3B9D,YAL2B,EAM3B+D,MAN2B,EAO3BC,MAP2B,CAA7B;;AAUA,kBAAIL,QAAJ,EAAc;AACZhD,gBAAAA,SAAS,CAACkD,IAAV,CAAeF,QAAf;AACD;AACF;AAf2B;AAAA;AAAA;AAAA;AAAA;AAgB7B;AAjBU;AAAA;AAAA;AAAA;AAAA;AAkBZ;AACF;AACF,C,CAAC;AACF;;;AAEA,SAASC,YAAT,CACExD,OADF,EAEEG,4BAFF,EAGEF,qBAHF,EAIEyD,gCAJF,EAKE9D,YALF,EAME+D,MANF,EAOEC,MAPF,EAQE;AACA,8BAAmCD,MAAnC;AAAA,MAAOb,WAAP;AAAA,MAAoBe,KAApB;AAAA,MAA2BC,IAA3B;;AACA,+BAAmCF,MAAnC;AAAA,MAAOZ,WAAP;AAAA,MAAoBe,KAApB;AAAA,MAA2BC,IAA3B,cAFA,CAE2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMvC,oBAAoB,GACxBiC,gCAAgC,IAC/BZ,WAAW,KAAKE,WAAhB,IACC5D,YAAY,CAAC0D,WAAD,CADb,IAEC1D,YAAY,CAAC4D,WAAD,CAJhB;;AAMA,MAAI,CAACvB,oBAAL,EAA2B;AACzB;AACA,QAAMwC,KAAK,GAAGJ,KAAK,CAACK,IAAN,CAAWC,KAAzB;AACA,QAAMC,KAAK,GAAGL,KAAK,CAACG,IAAN,CAAWC,KAAzB;;AAEA,QAAIF,KAAK,KAAKG,KAAd,EAAqB;AACnB,aAAO,CACL,CAACxE,YAAD,cAAmBqE,KAAnB,sBAAkCG,KAAlC,6BADK,EAEL,CAACP,KAAD,CAFK,EAGL,CAACE,KAAD,CAHK,CAAP;AAKD,KAXwB,CAWvB;;;AAEF,QAAIM,kBAAkB,CAACR,KAAD,CAAlB,KAA8BQ,kBAAkB,CAACN,KAAD,CAApD,EAA6D;AAC3D,aAAO,CACL,CAACnE,YAAD,EAAe,+BAAf,CADK,EAEL,CAACiE,KAAD,CAFK,EAGL,CAACE,KAAD,CAHK,CAAP;AAKD;AACF,GArCD,CAqCE;;;AAEF,MAAMO,KAAK,GAAGR,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAACS,IAA/D;AACA,MAAMC,KAAK,GAAGR,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAACO,IAA/D;;AAEA,MAAID,KAAK,IAAIE,KAAT,IAAkBC,eAAe,CAACH,KAAD,EAAQE,KAAR,CAArC,EAAqD;AACnD,WAAO,CACL,CACE5E,YADF,4CAEoCjB,OAAO,CAAC2F,KAAD,CAF3C,sBAE4D3F,OAAO,CAC/D6F,KAD+D,CAFnE,QADK,EAOL,CAACX,KAAD,CAPK,EAQL,CAACE,KAAD,CARK,CAAP;AAUD,GArDD,CAqDE;AACF;AACA;;;AAEA,MAAMhB,aAAa,GAAGc,KAAK,CAACvD,YAA5B;AACA,MAAM2C,aAAa,GAAGc,KAAK,CAACzD,YAA5B;;AAEA,MAAIyC,aAAa,IAAIE,aAArB,EAAoC;AAClC,QAAM1C,SAAS,GAAGsC,oCAAoC,CACpD7C,OADoD,EAEpDG,4BAFoD,EAGpDF,qBAHoD,EAIpDwB,oBAJoD,EAKpD1C,YAAY,CAACuF,KAAD,CALwC,EAMpDvB,aANoD,EAOpDhE,YAAY,CAACyF,KAAD,CAPwC,EAQpDvB,aARoD,CAAtD;AAUA,WAAOyB,iBAAiB,CAACnE,SAAD,EAAYX,YAAZ,EAA0BiE,KAA1B,EAAiCE,KAAjC,CAAxB;AACD;AACF;;AAED,SAASM,kBAAT,CAA4BM,SAA5B,EAAuC;AACrC,MAAIC,oBAAJ,CADqC,CAGrC;;;AACA,MAAMC,IAAI;AACR;AACA,GAACD,oBAAoB,GAAGD,SAAS,CAACG,SAAlC,MAAiD,IAAjD,IACAF,oBAAoB,KAAK,KAAK,CAD9B,GAEIA,oBAFJ,GAGI,EALN;AAMA,MAAMG,mBAAmB,GAAG;AAC1BC,IAAAA,IAAI,EAAEnG,IAAI,CAACoG,MADe;AAE1B3B,IAAAA,MAAM,EAAEuB,IAAI,CAAClF,GAAL,CAAS,UAACuF,OAAD;AAAA,aAAc;AAC7BF,QAAAA,IAAI,EAAEnG,IAAI,CAACsG,YADkB;AAE7BjB,QAAAA,IAAI,EAAEgB,OAAO,CAAChB,IAFe;AAG7BC,QAAAA,KAAK,EAAEe,OAAO,CAACf;AAHc,OAAd;AAAA,KAAT;AAFkB,GAA5B;AAQA,SAAOrF,KAAK,CAACO,aAAa,CAAC0F,mBAAD,CAAd,CAAZ;AACD,C,CAAC;AACF;AACA;;;AAEA,SAASN,eAAT,CAAyBH,KAAzB,EAAgCE,KAAhC,EAAuC;AACrC,MAAItF,UAAU,CAACoF,KAAD,CAAd,EAAuB;AACrB,WAAOpF,UAAU,CAACsF,KAAD,CAAV,GACHC,eAAe,CAACH,KAAK,CAACc,MAAP,EAAeZ,KAAK,CAACY,MAArB,CADZ,GAEH,IAFJ;AAGD;;AAED,MAAIlG,UAAU,CAACsF,KAAD,CAAd,EAAuB;AACrB,WAAO,IAAP;AACD;;AAED,MAAIrF,aAAa,CAACmF,KAAD,CAAjB,EAA0B;AACxB,WAAOnF,aAAa,CAACqF,KAAD,CAAb,GACHC,eAAe,CAACH,KAAK,CAACc,MAAP,EAAeZ,KAAK,CAACY,MAArB,CADZ,GAEH,IAFJ;AAGD;;AAED,MAAIjG,aAAa,CAACqF,KAAD,CAAjB,EAA0B;AACxB,WAAO,IAAP;AACD;;AAED,MAAIvF,UAAU,CAACqF,KAAD,CAAV,IAAqBrF,UAAU,CAACuF,KAAD,CAAnC,EAA4C;AAC1C,WAAOF,KAAK,KAAKE,KAAjB;AACD;;AAED,SAAO,KAAP;AACD,C,CAAC;AACF;AACA;;;AAEA,SAASxD,yBAAT,CACEhB,OADF,EAEEG,4BAFF,EAGEY,UAHF,EAIET,YAJF,EAKE;AACA,MAAM+E,MAAM,GAAGlF,4BAA4B,CAACmF,GAA7B,CAAiChF,YAAjC,CAAf;;AAEA,MAAI+E,MAAJ,EAAY;AACV,WAAOA,MAAP;AACD;;AAED,MAAME,WAAW,GAAGnC,MAAM,CAACoC,MAAP,CAAc,IAAd,CAApB;AACA,MAAMtE,aAAa,GAAGkC,MAAM,CAACoC,MAAP,CAAc,IAAd,CAAtB;;AAEAC,EAAAA,8BAA8B,CAC5BzF,OAD4B,EAE5Be,UAF4B,EAG5BT,YAH4B,EAI5BiF,WAJ4B,EAK5BrE,aAL4B,CAA9B;;AAQA,MAAMwE,MAAM,GAAG,CAACH,WAAD,EAAcnC,MAAM,CAACuC,IAAP,CAAYzE,aAAZ,CAAd,CAAf;AACAf,EAAAA,4BAA4B,CAACyF,GAA7B,CAAiCtF,YAAjC,EAA+CoF,MAA/C;AACA,SAAOA,MAAP;AACD,C,CAAC;AACF;;;AAEA,SAAS7D,mCAAT,CACE7B,OADF,EAEEG,4BAFF,EAGEwB,QAHF,EAIE;AACA;AACA,MAAM0D,MAAM,GAAGlF,4BAA4B,CAACmF,GAA7B,CAAiC3D,QAAQ,CAACrB,YAA1C,CAAf;;AAEA,MAAI+E,MAAJ,EAAY;AACV,WAAOA,MAAP;AACD;;AAED,MAAMQ,YAAY,GAAGvG,WAAW,CAACU,OAAO,CAAC8F,SAAR,EAAD,EAAsBnE,QAAQ,CAACoE,aAA/B,CAAhC;AACA,SAAO/E,yBAAyB,CAC9BhB,OAD8B,EAE9BG,4BAF8B,EAG9B0F,YAH8B,EAI9BlE,QAAQ,CAACrB,YAJqB,CAAhC;AAMD;;AAED,SAASmF,8BAAT,CACEzF,OADF,EAEEe,UAFF,EAGET,YAHF,EAIEiF,WAJF,EAKErE,aALF,EAME;AAAA,+CACwBZ,YAAY,CAAC0F,UADrC;AAAA;;AAAA;AACA,8DAAiD;AAAA,UAAtCC,SAAsC;;AAC/C,cAAQA,SAAS,CAACjB,IAAlB;AACE,aAAKnG,IAAI,CAACqH,KAAV;AAAiB;AACf,gBAAMC,SAAS,GAAGF,SAAS,CAAC/B,IAAV,CAAeC,KAAjC;AACA,gBAAIiC,QAAQ,SAAZ;;AAEA,gBAAIhH,YAAY,CAAC2B,UAAD,CAAZ,IAA4B/B,eAAe,CAAC+B,UAAD,CAA/C,EAA6D;AAC3DqF,cAAAA,QAAQ,GAAGrF,UAAU,CAACsF,SAAX,GAAuBF,SAAvB,CAAX;AACD;;AAED,gBAAMvG,YAAY,GAAGqG,SAAS,CAACK,KAAV,GACjBL,SAAS,CAACK,KAAV,CAAgBnC,KADC,GAEjBgC,SAFJ;;AAIA,gBAAI,CAACZ,WAAW,CAAC3F,YAAD,CAAhB,EAAgC;AAC9B2F,cAAAA,WAAW,CAAC3F,YAAD,CAAX,GAA4B,EAA5B;AACD;;AAED2F,YAAAA,WAAW,CAAC3F,YAAD,CAAX,CAA0B6D,IAA1B,CAA+B,CAAC1C,UAAD,EAAakF,SAAb,EAAwBG,QAAxB,CAA/B;AACA;AACD;;AAED,aAAKvH,IAAI,CAAC0H,eAAV;AACErF,UAAAA,aAAa,CAAC+E,SAAS,CAAC/B,IAAV,CAAeC,KAAhB,CAAb,GAAsC,IAAtC;AACA;;AAEF,aAAKtF,IAAI,CAAC2H,eAAV;AAA2B;AACzB,gBAAMT,aAAa,GAAGE,SAAS,CAACF,aAAhC;AACA,gBAAMU,kBAAkB,GAAGV,aAAa,GACpCzG,WAAW,CAACU,OAAO,CAAC8F,SAAR,EAAD,EAAsBC,aAAtB,CADyB,GAEpChF,UAFJ;;AAIA0E,YAAAA,8BAA8B,CAC5BzF,OAD4B,EAE5ByG,kBAF4B,EAG5BR,SAAS,CAAC3F,YAHkB,EAI5BiF,WAJ4B,EAK5BrE,aAL4B,CAA9B;;AAQA;AACD;AAxCH;AA0CD;AA5CD;AAAA;AAAA;AAAA;AAAA;AA6CD,C,CAAC;AACF;;;AAEA,SAASwD,iBAAT,CAA2BnE,SAA3B,EAAsCX,YAAtC,EAAoDiE,KAApD,EAA2DE,KAA3D,EAAkE;AAChE,MAAIxD,SAAS,CAACa,MAAV,GAAmB,CAAvB,EAA0B;AACxB,WAAO,CACL,CAACxB,YAAD,EAAeW,SAAS,CAACZ,GAAV,CAAc;AAAA;AAAA,UAAEH,MAAF;;AAAA,aAAcA,MAAd;AAAA,KAAd,CAAf,CADK,GAEJqE,KAFI,4BAEMtD,SAAS,CAACZ,GAAV,CAAc;AAAA;AAAA,UAAIe,OAAJ;;AAAA,aAAiBA,OAAjB;AAAA,KAAd,EAAwCgG,IAAxC,EAFN,KAGJ3C,KAHI,4BAGMxD,SAAS,CAACZ,GAAV,CAAc;AAAA;AAAA,UAAMgB,OAAN;;AAAA,aAAmBA,OAAnB;AAAA,KAAd,EAA0C+F,IAA1C,EAHN,GAAP;AAKD;AACF;AACD;AACA;AACA;;;IAEMxG,O;AACJ,qBAAc;AAAA;;AACZ,SAAKyG,KAAL,GAAa,IAAIvG,GAAJ,EAAb;AACD;;;;WAED,aAAIwG,CAAJ,EAAOC,CAAP,EAAUpF,oBAAV,EAAgC;AAC9B,UAAIqF,eAAJ;;AAEA,kBAAqBF,CAAC,GAAGC,CAAJ,GAAQ,CAACD,CAAD,EAAIC,CAAJ,CAAR,GAAiB,CAACA,CAAD,EAAID,CAAJ,CAAtC;AAAA;AAAA,UAAOG,IAAP;AAAA,UAAaC,IAAb;;AACA,UAAMtB,MAAM,GACV,CAACoB,eAAe,GAAG,KAAKH,KAAL,CAAWrB,GAAX,CAAeyB,IAAf,CAAnB,MAA6C,IAA7C,IACAD,eAAe,KAAK,KAAK,CADzB,GAEI,KAAK,CAFT,GAGIA,eAAe,CAACxB,GAAhB,CAAoB0B,IAApB,CAJN;;AAMA,UAAItB,MAAM,KAAKuB,SAAf,EAA0B;AACxB,eAAO,KAAP;AACD,OAZ6B,CAY5B;AACF;AACA;;;AAEA,aAAOxF,oBAAoB,GAAG,IAAH,GAAUA,oBAAoB,KAAKiE,MAA9D;AACD;;;WAED,aAAIkB,CAAJ,EAAOC,CAAP,EAAUpF,oBAAV,EAAgC;AAC9B,mBAAqBmF,CAAC,GAAGC,CAAJ,GAAQ,CAACD,CAAD,EAAIC,CAAJ,CAAR,GAAiB,CAACA,CAAD,EAAID,CAAJ,CAAtC;AAAA;AAAA,UAAOG,IAAP;AAAA,UAAaC,IAAb;;AAEA,UAAMrH,GAAG,GAAG,KAAKgH,KAAL,CAAWrB,GAAX,CAAeyB,IAAf,CAAZ;;AAEA,UAAIpH,GAAG,KAAKsH,SAAZ,EAAuB;AACrB,aAAKN,KAAL,CAAWf,GAAX,CAAemB,IAAf,EAAqB,IAAI3G,GAAJ,CAAQ,CAAC,CAAC4G,IAAD,EAAOvF,oBAAP,CAAD,CAAR,CAArB;AACD,OAFD,MAEO;AACL9B,QAAAA,GAAG,CAACiG,GAAJ,CAAQoB,IAAR,EAAcvF,oBAAd;AACD;AACF","sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  isInterfaceType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../../type/definition.mjs';\nimport { sortValueNode } from '../../utilities/sortValueNode.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason\n      .map(\n        ([responseName, subReason]) =>\n          `subfields \"${responseName}\" conflict because ` +\n          reasonMessage(subReason),\n      )\n      .join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  const cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(\n        context,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        context.getParentType(),\n        selectionSet,\n      );\n\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(\n          new GraphQLError(\n            `Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,\n            fields1.concat(fields2),\n          ),\n        );\n      }\n    },\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentType,\n  selectionSet,\n) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType,\n    selectionSet,\n  ); // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    fieldMap,\n  );\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        false,\n        fieldMap,\n        fragmentNames[i],\n      ); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(\n          context,\n          conflicts,\n          cachedFieldsAndFragmentNames,\n          comparedFragmentPairs,\n          false,\n          fragmentNames[i],\n          fragmentNames[j],\n        );\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\nfunction collectConflictsBetweenFieldsAndFragment(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fieldMap,\n  fragmentName,\n) {\n  const fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  const [fieldMap2, referencedFragmentNames] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment,\n    ); // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap,\n    fieldMap2,\n  ); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (const referencedFragmentName of referencedFragmentNames) {\n    // Memoize so two fragments are not compared for conflicts more than once.\n    if (\n      comparedFragmentPairs.has(\n        referencedFragmentName,\n        fragmentName,\n        areMutuallyExclusive,\n      )\n    ) {\n      continue;\n    }\n\n    comparedFragmentPairs.add(\n      referencedFragmentName,\n      fragmentName,\n      areMutuallyExclusive,\n    );\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap,\n      referencedFragmentName,\n    );\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\nfunction collectConflictsBetweenFragments(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fragmentName1,\n  fragmentName2,\n) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n  if (\n    comparedFragmentPairs.has(\n      fragmentName1,\n      fragmentName2,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  const [fieldMap1, referencedFragmentNames1] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment1,\n    );\n  const [fieldMap2, referencedFragmentNames2] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment2,\n    ); // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fragmentName1,\n      referencedFragmentName2,\n    );\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      referencedFragmentName1,\n      fragmentName2,\n    );\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\nfunction findConflictsBetweenSubSelectionSets(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  parentType1,\n  selectionSet1,\n  parentType2,\n  selectionSet2,\n) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType1,\n    selectionSet1,\n  );\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType2,\n    selectionSet2,\n  ); // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap1,\n      fragmentName2,\n    );\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap2,\n      fragmentName1,\n    );\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        areMutuallyExclusive,\n        fragmentName1,\n        fragmentName2,\n      );\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\nfunction collectConflictsWithin(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  fieldMap,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            false, // within one collection is never mutually exclusive\n            responseName,\n            fields[i],\n            fields[j],\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\nfunction collectConflictsBetween(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  fieldMap1,\n  fieldMap2,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            parentFieldsAreMutuallyExclusive,\n            responseName,\n            field1,\n            field2,\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\nfunction findConflict(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  responseName,\n  field1,\n  field2,\n) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  const areMutuallyExclusive =\n    parentFieldsAreMutuallyExclusive ||\n    (parentType1 !== parentType2 &&\n      isObjectType(parentType1) &&\n      isObjectType(parentType2));\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\n        [node1],\n        [node2],\n      ];\n    } // Two field calls must have the same arguments.\n\n    if (stringifyArguments(node1) !== stringifyArguments(node2)) {\n      return [\n        [responseName, 'they have differing arguments'],\n        [node1],\n        [node2],\n      ];\n    }\n  } // The return type for each field.\n\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [\n      [\n        responseName,\n        `they return conflicting types \"${inspect(type1)}\" and \"${inspect(\n          type2,\n        )}\"`,\n      ],\n      [node1],\n      [node2],\n    ];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(\n      context,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      getNamedType(type1),\n      selectionSet1,\n      getNamedType(type2),\n      selectionSet2,\n    );\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction stringifyArguments(fieldNode) {\n  var _fieldNode$arguments;\n\n  // FIXME https://github.com/graphql/graphql-js/issues/2203\n  const args =\n    /* c8 ignore next */\n    (_fieldNode$arguments = fieldNode.arguments) !== null &&\n    _fieldNode$arguments !== void 0\n      ? _fieldNode$arguments\n      : [];\n  const inputObjectWithArgs = {\n    kind: Kind.OBJECT,\n    fields: args.map((argNode) => ({\n      kind: Kind.OBJECT_FIELD,\n      name: argNode.name,\n      value: argNode.value,\n    })),\n  };\n  return print(sortValueNode(inputObjectWithArgs));\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\nfunction getFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  parentType,\n  selectionSet,\n) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const nodeAndDefs = Object.create(null);\n  const fragmentNames = Object.create(null);\n\n  _collectFieldsAndFragmentNames(\n    context,\n    parentType,\n    selectionSet,\n    nodeAndDefs,\n    fragmentNames,\n  );\n\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\nfunction getReferencedFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  fragment,\n) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    fragmentType,\n    fragment.selectionSet,\n  );\n}\n\nfunction _collectFieldsAndFragmentNames(\n  context,\n  parentType,\n  selectionSet,\n  nodeAndDefs,\n  fragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        const fieldName = selection.name.value;\n        let fieldDef;\n\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        const responseName = selection.alias\n          ? selection.alias.value\n          : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT: {\n        const typeCondition = selection.typeCondition;\n        const inlineFragmentType = typeCondition\n          ? typeFromAST(context.getSchema(), typeCondition)\n          : parentType;\n\n        _collectFieldsAndFragmentNames(\n          context,\n          inlineFragmentType,\n          selection.selectionSet,\n          nodeAndDefs,\n          fragmentNames,\n        );\n\n        break;\n      }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [\n      [responseName, conflicts.map(([reason]) => reason)],\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()],\n    ];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does not matter.\n */\n\nclass PairSet {\n  constructor() {\n    this._data = new Map();\n  }\n\n  has(a, b, areMutuallyExclusive) {\n    var _this$_data$get;\n\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n    const result =\n      (_this$_data$get = this._data.get(key1)) === null ||\n      _this$_data$get === void 0\n        ? void 0\n        : _this$_data$get.get(key2);\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true, hence if\n    // we want to know if this PairSet \"has\" these two with no exclusivity,\n    // we have to ensure it was added as such.\n\n    return areMutuallyExclusive ? true : areMutuallyExclusive === result;\n  }\n\n  add(a, b, areMutuallyExclusive) {\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n\n    const map = this._data.get(key1);\n\n    if (map === undefined) {\n      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));\n    } else {\n      map.set(key2, areMutuallyExclusive);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}