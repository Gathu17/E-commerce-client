{"ast":null,"code":"import _inherits from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createForOfIteratorHelper from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\n\nexport var ASTValidationContext = /*#__PURE__*/function (_Symbol$toStringTag) {\n  function ASTValidationContext(ast, onError) {\n    _classCallCheck(this, ASTValidationContext);\n\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  _createClass(ASTValidationContext, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'ASTValidationContext';\n    }\n  }, {\n    key: \"reportError\",\n    value: function reportError(error) {\n      this._onError(error);\n    }\n  }, {\n    key: \"getDocument\",\n    value: function getDocument() {\n      return this._ast;\n    }\n  }, {\n    key: \"getFragment\",\n    value: function getFragment(name) {\n      var fragments;\n\n      if (this._fragments) {\n        fragments = this._fragments;\n      } else {\n        fragments = Object.create(null);\n\n        var _iterator = _createForOfIteratorHelper(this.getDocument().definitions),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var defNode = _step.value;\n\n            if (defNode.kind === Kind.FRAGMENT_DEFINITION) {\n              fragments[defNode.name.value] = defNode;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        this._fragments = fragments;\n      }\n\n      return fragments[name];\n    }\n  }, {\n    key: \"getFragmentSpreads\",\n    value: function getFragmentSpreads(node) {\n      var spreads = this._fragmentSpreads.get(node);\n\n      if (!spreads) {\n        spreads = [];\n        var setsToVisit = [node];\n        var set;\n\n        while (set = setsToVisit.pop()) {\n          var _iterator2 = _createForOfIteratorHelper(set.selections),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var selection = _step2.value;\n\n              if (selection.kind === Kind.FRAGMENT_SPREAD) {\n                spreads.push(selection);\n              } else if (selection.selectionSet) {\n                setsToVisit.push(selection.selectionSet);\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n\n        this._fragmentSpreads.set(node, spreads);\n      }\n\n      return spreads;\n    }\n  }, {\n    key: \"getRecursivelyReferencedFragments\",\n    value: function getRecursivelyReferencedFragments(operation) {\n      var fragments = this._recursivelyReferencedFragments.get(operation);\n\n      if (!fragments) {\n        fragments = [];\n        var collectedNames = Object.create(null);\n        var nodesToVisit = [operation.selectionSet];\n        var node;\n\n        while (node = nodesToVisit.pop()) {\n          var _iterator3 = _createForOfIteratorHelper(this.getFragmentSpreads(node)),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var spread = _step3.value;\n              var fragName = spread.name.value;\n\n              if (collectedNames[fragName] !== true) {\n                collectedNames[fragName] = true;\n                var fragment = this.getFragment(fragName);\n\n                if (fragment) {\n                  fragments.push(fragment);\n                  nodesToVisit.push(fragment.selectionSet);\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n\n        this._recursivelyReferencedFragments.set(operation, fragments);\n      }\n\n      return fragments;\n    }\n  }]);\n\n  return ASTValidationContext;\n}(Symbol.toStringTag);\nexport var SDLValidationContext = /*#__PURE__*/function (_ASTValidationContext, _Symbol$toStringTag2) {\n  _inherits(SDLValidationContext, _ASTValidationContext);\n\n  var _super = _createSuper(SDLValidationContext);\n\n  function SDLValidationContext(ast, schema, onError) {\n    var _this;\n\n    _classCallCheck(this, SDLValidationContext);\n\n    _this = _super.call(this, ast, onError);\n    _this._schema = schema;\n    return _this;\n  }\n\n  _createClass(SDLValidationContext, [{\n    key: _Symbol$toStringTag2,\n    get: function get() {\n      return 'SDLValidationContext';\n    }\n  }, {\n    key: \"getSchema\",\n    value: function getSchema() {\n      return this._schema;\n    }\n  }]);\n\n  return SDLValidationContext;\n}(ASTValidationContext, Symbol.toStringTag);\nexport var ValidationContext = /*#__PURE__*/function (_ASTValidationContext2, _Symbol$toStringTag3) {\n  _inherits(ValidationContext, _ASTValidationContext2);\n\n  var _super2 = _createSuper(ValidationContext);\n\n  function ValidationContext(schema, ast, typeInfo, onError) {\n    var _this2;\n\n    _classCallCheck(this, ValidationContext);\n\n    _this2 = _super2.call(this, ast, onError);\n    _this2._schema = schema;\n    _this2._typeInfo = typeInfo;\n    _this2._variableUsages = new Map();\n    _this2._recursiveVariableUsages = new Map();\n    return _this2;\n  }\n\n  _createClass(ValidationContext, [{\n    key: _Symbol$toStringTag3,\n    get: function get() {\n      return 'ValidationContext';\n    }\n  }, {\n    key: \"getSchema\",\n    value: function getSchema() {\n      return this._schema;\n    }\n  }, {\n    key: \"getVariableUsages\",\n    value: function getVariableUsages(node) {\n      var usages = this._variableUsages.get(node);\n\n      if (!usages) {\n        var newUsages = [];\n        var typeInfo = new TypeInfo(this._schema);\n        visit(node, visitWithTypeInfo(typeInfo, {\n          VariableDefinition: function VariableDefinition() {\n            return false;\n          },\n          Variable: function Variable(variable) {\n            newUsages.push({\n              node: variable,\n              type: typeInfo.getInputType(),\n              defaultValue: typeInfo.getDefaultValue()\n            });\n          }\n        }));\n        usages = newUsages;\n\n        this._variableUsages.set(node, usages);\n      }\n\n      return usages;\n    }\n  }, {\n    key: \"getRecursiveVariableUsages\",\n    value: function getRecursiveVariableUsages(operation) {\n      var usages = this._recursiveVariableUsages.get(operation);\n\n      if (!usages) {\n        usages = this.getVariableUsages(operation);\n\n        var _iterator4 = _createForOfIteratorHelper(this.getRecursivelyReferencedFragments(operation)),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var frag = _step4.value;\n            usages = usages.concat(this.getVariableUsages(frag));\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        this._recursiveVariableUsages.set(operation, usages);\n      }\n\n      return usages;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return this._typeInfo.getType();\n    }\n  }, {\n    key: \"getParentType\",\n    value: function getParentType() {\n      return this._typeInfo.getParentType();\n    }\n  }, {\n    key: \"getInputType\",\n    value: function getInputType() {\n      return this._typeInfo.getInputType();\n    }\n  }, {\n    key: \"getParentInputType\",\n    value: function getParentInputType() {\n      return this._typeInfo.getParentInputType();\n    }\n  }, {\n    key: \"getFieldDef\",\n    value: function getFieldDef() {\n      return this._typeInfo.getFieldDef();\n    }\n  }, {\n    key: \"getDirective\",\n    value: function getDirective() {\n      return this._typeInfo.getDirective();\n    }\n  }, {\n    key: \"getArgument\",\n    value: function getArgument() {\n      return this._typeInfo.getArgument();\n    }\n  }, {\n    key: \"getEnumValue\",\n    value: function getEnumValue() {\n      return this._typeInfo.getEnumValue();\n    }\n  }]);\n\n  return ValidationContext;\n}(ASTValidationContext, Symbol.toStringTag);","map":{"version":3,"sources":["C:/Users/GATHU/Desktop/node_modules/graphql/validation/ValidationContext.mjs"],"names":["Kind","visit","TypeInfo","visitWithTypeInfo","ASTValidationContext","ast","onError","_ast","_fragments","undefined","_fragmentSpreads","Map","_recursivelyReferencedFragments","_onError","error","name","fragments","Object","create","getDocument","definitions","defNode","kind","FRAGMENT_DEFINITION","value","node","spreads","get","setsToVisit","set","pop","selections","selection","FRAGMENT_SPREAD","push","selectionSet","operation","collectedNames","nodesToVisit","getFragmentSpreads","spread","fragName","fragment","getFragment","Symbol","toStringTag","SDLValidationContext","schema","_schema","ValidationContext","typeInfo","_typeInfo","_variableUsages","_recursiveVariableUsages","usages","newUsages","VariableDefinition","Variable","variable","type","getInputType","defaultValue","getDefaultValue","getVariableUsages","getRecursivelyReferencedFragments","frag","concat","getType","getParentType","getParentInputType","getFieldDef","getDirective","getArgument","getEnumValue"],"mappings":"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","sourcesContent":["import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport class ASTValidationContext {\n  constructor(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n\n  reportError(error) {\n    this._onError(error);\n  }\n\n  getDocument() {\n    return this._ast;\n  }\n\n  getFragment(name) {\n    let fragments;\n\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n\n      this._fragments = fragments;\n    }\n\n    return fragments[name];\n  }\n\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set;\n\n      while ((set = setsToVisit.pop())) {\n        for (const selection of set.selections) {\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  }\n\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n\n      while ((node = nodesToVisit.pop())) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  }\n}\nexport class SDLValidationContext extends ASTValidationContext {\n  constructor(ast, schema, onError) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n}\nexport class ValidationContext extends ASTValidationContext {\n  constructor(schema, ast, typeInfo, onError) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new TypeInfo(this._schema);\n      visit(\n        node,\n        visitWithTypeInfo(typeInfo, {\n          VariableDefinition: () => false,\n\n          Variable(variable) {\n            newUsages.push({\n              node: variable,\n              type: typeInfo.getInputType(),\n              defaultValue: typeInfo.getDefaultValue(),\n            });\n          },\n        }),\n      );\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  }\n\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  }\n\n  getType() {\n    return this._typeInfo.getType();\n  }\n\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}