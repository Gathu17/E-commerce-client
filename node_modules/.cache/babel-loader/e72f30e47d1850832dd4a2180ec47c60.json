{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  var _iterator = _createForOfIteratorHelper(documentAST.definitions),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var definitionNode = _step.value;\n\n      switch (definitionNode.kind) {\n        case Kind.OPERATION_DEFINITION:\n          operations.push(definitionNode);\n          break;\n\n        case Kind.FRAGMENT_DEFINITION:\n          depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);\n          break;\n\n        default: // ignore non-executable definitions\n\n      }\n    } // For each operation, produce a new synthesized AST which includes only what\n    // is necessary for completing that operation.\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var separatedDocumentASTs = Object.create(null);\n\n  var _loop = function _loop() {\n    var operation = _operations[_i];\n    var dependencies = new Set();\n\n    var _iterator2 = _createForOfIteratorHelper(collectDependencies(operation.selectionSet)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var fragmentName = _step2.value;\n        collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n      } // Provides the empty string for anonymous operations.\n\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    var operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(function (node) {\n        return node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value);\n      })\n    };\n  };\n\n  for (var _i = 0, _operations = operations; _i < _operations.length; _i++) {\n    _loop();\n  }\n\n  return separatedDocumentASTs;\n} // From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\n\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    var immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      var _iterator3 = _createForOfIteratorHelper(immediateDeps),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var toName = _step3.value;\n          collectTransitiveDependencies(collected, depGraph, toName);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  var dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread: function FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    }\n  });\n  return dependencies;\n}","map":{"version":3,"sources":["C:/Users/GATHU/Desktop/node_modules/graphql/utilities/separateOperations.mjs"],"names":["Kind","visit","separateOperations","documentAST","operations","depGraph","Object","create","definitions","definitionNode","kind","OPERATION_DEFINITION","push","FRAGMENT_DEFINITION","name","value","collectDependencies","selectionSet","separatedDocumentASTs","operation","dependencies","Set","fragmentName","collectTransitiveDependencies","operationName","DOCUMENT","filter","node","has","collected","fromName","add","immediateDeps","undefined","toName","FragmentSpread"],"mappings":"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","sourcesContent":["import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  const operations = [];\n  const depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (const definitionNode of documentAST.definitions) {\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(\n          definitionNode.selectionSet,\n        );\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  const separatedDocumentASTs = Object.create(null);\n\n  for (const operation of operations) {\n    const dependencies = new Set();\n\n    for (const fragmentName of collectDependencies(operation.selectionSet)) {\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n    const operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(\n        (node) =>\n          node === operation ||\n          (node.kind === Kind.FRAGMENT_DEFINITION &&\n            dependencies.has(node.name.value)),\n      ),\n    };\n  }\n\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    const immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (const toName of immediateDeps) {\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  const dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    },\n  });\n  return dependencies;\n}\n"]},"metadata":{},"sourceType":"module"}