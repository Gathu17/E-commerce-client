{"ast":null,"code":"import _toConsumableArray from \"C:/Users/GATHU/Desktop/E-client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isPrintableAsBlockString } from '../language/blockString.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { print } from '../language/printer.mjs';\nimport { isEnumType, isInputObjectType, isInterfaceType, isObjectType, isScalarType, isUnionType } from '../type/definition.mjs';\nimport { DEFAULT_DEPRECATION_REASON, isSpecifiedDirective } from '../type/directives.mjs';\nimport { isIntrospectionType } from '../type/introspection.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nexport function printSchema(schema) {\n  return printFilteredSchema(schema, function (n) {\n    return !isSpecifiedDirective(n);\n  }, isDefinedType);\n}\nexport function printIntrospectionSchema(schema) {\n  return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType);\n}\n\nfunction isDefinedType(type) {\n  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);\n}\n\nfunction printFilteredSchema(schema, directiveFilter, typeFilter) {\n  var directives = schema.getDirectives().filter(directiveFilter);\n  var types = Object.values(schema.getTypeMap()).filter(typeFilter);\n  return [printSchemaDefinition(schema)].concat(_toConsumableArray(directives.map(function (directive) {\n    return printDirective(directive);\n  })), _toConsumableArray(types.map(function (type) {\n    return printType(type);\n  }))).filter(Boolean).join('\\n\\n');\n}\n\nfunction printSchemaDefinition(schema) {\n  if (schema.description == null && isSchemaOfCommonNames(schema)) {\n    return;\n  }\n\n  var operationTypes = [];\n  var queryType = schema.getQueryType();\n\n  if (queryType) {\n    operationTypes.push(\"  query: \".concat(queryType.name));\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType) {\n    operationTypes.push(\"  mutation: \".concat(mutationType.name));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType) {\n    operationTypes.push(\"  subscription: \".concat(subscriptionType.name));\n  }\n\n  return printDescription(schema) + \"schema {\\n\".concat(operationTypes.join('\\n'), \"\\n}\");\n}\n/**\n * GraphQL schema define root types for each type of operation. These types are\n * the same as any other type and can be named in any manner, however there is\n * a common naming convention:\n *\n * ```graphql\n *   schema {\n *     query: Query\n *     mutation: Mutation\n *     subscription: Subscription\n *   }\n * ```\n *\n * When using this naming convention, the schema description can be omitted.\n */\n\n\nfunction isSchemaOfCommonNames(schema) {\n  var queryType = schema.getQueryType();\n\n  if (queryType && queryType.name !== 'Query') {\n    return false;\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && mutationType.name !== 'Mutation') {\n    return false;\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && subscriptionType.name !== 'Subscription') {\n    return false;\n  }\n\n  return true;\n}\n\nexport function printType(type) {\n  if (isScalarType(type)) {\n    return printScalar(type);\n  }\n\n  if (isObjectType(type)) {\n    return printObject(type);\n  }\n\n  if (isInterfaceType(type)) {\n    return printInterface(type);\n  }\n\n  if (isUnionType(type)) {\n    return printUnion(type);\n  }\n\n  if (isEnumType(type)) {\n    return printEnum(type);\n  }\n\n  if (isInputObjectType(type)) {\n    return printInputObject(type);\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction printScalar(type) {\n  return printDescription(type) + \"scalar \".concat(type.name) + printSpecifiedByURL(type);\n}\n\nfunction printImplementedInterfaces(type) {\n  var interfaces = type.getInterfaces();\n  return interfaces.length ? ' implements ' + interfaces.map(function (i) {\n    return i.name;\n  }).join(' & ') : '';\n}\n\nfunction printObject(type) {\n  return printDescription(type) + \"type \".concat(type.name) + printImplementedInterfaces(type) + printFields(type);\n}\n\nfunction printInterface(type) {\n  return printDescription(type) + \"interface \".concat(type.name) + printImplementedInterfaces(type) + printFields(type);\n}\n\nfunction printUnion(type) {\n  var types = type.getTypes();\n  var possibleTypes = types.length ? ' = ' + types.join(' | ') : '';\n  return printDescription(type) + 'union ' + type.name + possibleTypes;\n}\n\nfunction printEnum(type) {\n  var values = type.getValues().map(function (value, i) {\n    return printDescription(value, '  ', !i) + '  ' + value.name + printDeprecated(value.deprecationReason);\n  });\n  return printDescription(type) + \"enum \".concat(type.name) + printBlock(values);\n}\n\nfunction printInputObject(type) {\n  var fields = Object.values(type.getFields()).map(function (f, i) {\n    return printDescription(f, '  ', !i) + '  ' + printInputValue(f);\n  });\n  return printDescription(type) + \"input \".concat(type.name) + printBlock(fields);\n}\n\nfunction printFields(type) {\n  var fields = Object.values(type.getFields()).map(function (f, i) {\n    return printDescription(f, '  ', !i) + '  ' + f.name + printArgs(f.args, '  ') + ': ' + String(f.type) + printDeprecated(f.deprecationReason);\n  });\n  return printBlock(fields);\n}\n\nfunction printBlock(items) {\n  return items.length !== 0 ? ' {\\n' + items.join('\\n') + '\\n}' : '';\n}\n\nfunction printArgs(args) {\n  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  if (args.length === 0) {\n    return '';\n  } // If every arg does not have a description, print them on one line.\n\n\n  if (args.every(function (arg) {\n    return !arg.description;\n  })) {\n    return '(' + args.map(printInputValue).join(', ') + ')';\n  }\n\n  return '(\\n' + args.map(function (arg, i) {\n    return printDescription(arg, '  ' + indentation, !i) + '  ' + indentation + printInputValue(arg);\n  }).join('\\n') + '\\n' + indentation + ')';\n}\n\nfunction printInputValue(arg) {\n  var defaultAST = astFromValue(arg.defaultValue, arg.type);\n  var argDecl = arg.name + ': ' + String(arg.type);\n\n  if (defaultAST) {\n    argDecl += \" = \".concat(print(defaultAST));\n  }\n\n  return argDecl + printDeprecated(arg.deprecationReason);\n}\n\nfunction printDirective(directive) {\n  return printDescription(directive) + 'directive @' + directive.name + printArgs(directive.args) + (directive.isRepeatable ? ' repeatable' : '') + ' on ' + directive.locations.join(' | ');\n}\n\nfunction printDeprecated(reason) {\n  if (reason == null) {\n    return '';\n  }\n\n  if (reason !== DEFAULT_DEPRECATION_REASON) {\n    var astValue = print({\n      kind: Kind.STRING,\n      value: reason\n    });\n    return \" @deprecated(reason: \".concat(astValue, \")\");\n  }\n\n  return ' @deprecated';\n}\n\nfunction printSpecifiedByURL(scalar) {\n  if (scalar.specifiedByURL == null) {\n    return '';\n  }\n\n  var astValue = print({\n    kind: Kind.STRING,\n    value: scalar.specifiedByURL\n  });\n  return \" @specifiedBy(url: \".concat(astValue, \")\");\n}\n\nfunction printDescription(def) {\n  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var firstInBlock = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var description = def.description;\n\n  if (description == null) {\n    return '';\n  }\n\n  var blockString = print({\n    kind: Kind.STRING,\n    value: description,\n    block: isPrintableAsBlockString(description)\n  });\n  var prefix = indentation && !firstInBlock ? '\\n' + indentation : indentation;\n  return prefix + blockString.replace(/\\n/g, '\\n' + indentation) + '\\n';\n}","map":{"version":3,"sources":["C:/Users/GATHU/Desktop/node_modules/graphql/utilities/printSchema.mjs"],"names":["inspect","invariant","isPrintableAsBlockString","Kind","print","isEnumType","isInputObjectType","isInterfaceType","isObjectType","isScalarType","isUnionType","DEFAULT_DEPRECATION_REASON","isSpecifiedDirective","isIntrospectionType","isSpecifiedScalarType","astFromValue","printSchema","schema","printFilteredSchema","n","isDefinedType","printIntrospectionSchema","type","directiveFilter","typeFilter","directives","getDirectives","filter","types","Object","values","getTypeMap","printSchemaDefinition","map","directive","printDirective","printType","Boolean","join","description","isSchemaOfCommonNames","operationTypes","queryType","getQueryType","push","name","mutationType","getMutationType","subscriptionType","getSubscriptionType","printDescription","printScalar","printObject","printInterface","printUnion","printEnum","printInputObject","printSpecifiedByURL","printImplementedInterfaces","interfaces","getInterfaces","length","i","printFields","getTypes","possibleTypes","getValues","value","printDeprecated","deprecationReason","printBlock","fields","getFields","f","printInputValue","printArgs","args","String","items","indentation","every","arg","defaultAST","defaultValue","argDecl","isRepeatable","locations","reason","astValue","kind","STRING","scalar","specifiedByURL","def","firstInBlock","blockString","block","prefix","replace"],"mappings":"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","sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isPrintableAsBlockString } from '../language/blockString.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { print } from '../language/printer.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport {\n  DEFAULT_DEPRECATION_REASON,\n  isSpecifiedDirective,\n} from '../type/directives.mjs';\nimport { isIntrospectionType } from '../type/introspection.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nexport function printSchema(schema) {\n  return printFilteredSchema(\n    schema,\n    (n) => !isSpecifiedDirective(n),\n    isDefinedType,\n  );\n}\nexport function printIntrospectionSchema(schema) {\n  return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType);\n}\n\nfunction isDefinedType(type) {\n  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);\n}\n\nfunction printFilteredSchema(schema, directiveFilter, typeFilter) {\n  const directives = schema.getDirectives().filter(directiveFilter);\n  const types = Object.values(schema.getTypeMap()).filter(typeFilter);\n  return [\n    printSchemaDefinition(schema),\n    ...directives.map((directive) => printDirective(directive)),\n    ...types.map((type) => printType(type)),\n  ]\n    .filter(Boolean)\n    .join('\\n\\n');\n}\n\nfunction printSchemaDefinition(schema) {\n  if (schema.description == null && isSchemaOfCommonNames(schema)) {\n    return;\n  }\n\n  const operationTypes = [];\n  const queryType = schema.getQueryType();\n\n  if (queryType) {\n    operationTypes.push(`  query: ${queryType.name}`);\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType) {\n    operationTypes.push(`  mutation: ${mutationType.name}`);\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType) {\n    operationTypes.push(`  subscription: ${subscriptionType.name}`);\n  }\n\n  return printDescription(schema) + `schema {\\n${operationTypes.join('\\n')}\\n}`;\n}\n/**\n * GraphQL schema define root types for each type of operation. These types are\n * the same as any other type and can be named in any manner, however there is\n * a common naming convention:\n *\n * ```graphql\n *   schema {\n *     query: Query\n *     mutation: Mutation\n *     subscription: Subscription\n *   }\n * ```\n *\n * When using this naming convention, the schema description can be omitted.\n */\n\nfunction isSchemaOfCommonNames(schema) {\n  const queryType = schema.getQueryType();\n\n  if (queryType && queryType.name !== 'Query') {\n    return false;\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && mutationType.name !== 'Mutation') {\n    return false;\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && subscriptionType.name !== 'Subscription') {\n    return false;\n  }\n\n  return true;\n}\n\nexport function printType(type) {\n  if (isScalarType(type)) {\n    return printScalar(type);\n  }\n\n  if (isObjectType(type)) {\n    return printObject(type);\n  }\n\n  if (isInterfaceType(type)) {\n    return printInterface(type);\n  }\n\n  if (isUnionType(type)) {\n    return printUnion(type);\n  }\n\n  if (isEnumType(type)) {\n    return printEnum(type);\n  }\n\n  if (isInputObjectType(type)) {\n    return printInputObject(type);\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction printScalar(type) {\n  return (\n    printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type)\n  );\n}\n\nfunction printImplementedInterfaces(type) {\n  const interfaces = type.getInterfaces();\n  return interfaces.length\n    ? ' implements ' + interfaces.map((i) => i.name).join(' & ')\n    : '';\n}\n\nfunction printObject(type) {\n  return (\n    printDescription(type) +\n    `type ${type.name}` +\n    printImplementedInterfaces(type) +\n    printFields(type)\n  );\n}\n\nfunction printInterface(type) {\n  return (\n    printDescription(type) +\n    `interface ${type.name}` +\n    printImplementedInterfaces(type) +\n    printFields(type)\n  );\n}\n\nfunction printUnion(type) {\n  const types = type.getTypes();\n  const possibleTypes = types.length ? ' = ' + types.join(' | ') : '';\n  return printDescription(type) + 'union ' + type.name + possibleTypes;\n}\n\nfunction printEnum(type) {\n  const values = type\n    .getValues()\n    .map(\n      (value, i) =>\n        printDescription(value, '  ', !i) +\n        '  ' +\n        value.name +\n        printDeprecated(value.deprecationReason),\n    );\n  return printDescription(type) + `enum ${type.name}` + printBlock(values);\n}\n\nfunction printInputObject(type) {\n  const fields = Object.values(type.getFields()).map(\n    (f, i) => printDescription(f, '  ', !i) + '  ' + printInputValue(f),\n  );\n  return printDescription(type) + `input ${type.name}` + printBlock(fields);\n}\n\nfunction printFields(type) {\n  const fields = Object.values(type.getFields()).map(\n    (f, i) =>\n      printDescription(f, '  ', !i) +\n      '  ' +\n      f.name +\n      printArgs(f.args, '  ') +\n      ': ' +\n      String(f.type) +\n      printDeprecated(f.deprecationReason),\n  );\n  return printBlock(fields);\n}\n\nfunction printBlock(items) {\n  return items.length !== 0 ? ' {\\n' + items.join('\\n') + '\\n}' : '';\n}\n\nfunction printArgs(args, indentation = '') {\n  if (args.length === 0) {\n    return '';\n  } // If every arg does not have a description, print them on one line.\n\n  if (args.every((arg) => !arg.description)) {\n    return '(' + args.map(printInputValue).join(', ') + ')';\n  }\n\n  return (\n    '(\\n' +\n    args\n      .map(\n        (arg, i) =>\n          printDescription(arg, '  ' + indentation, !i) +\n          '  ' +\n          indentation +\n          printInputValue(arg),\n      )\n      .join('\\n') +\n    '\\n' +\n    indentation +\n    ')'\n  );\n}\n\nfunction printInputValue(arg) {\n  const defaultAST = astFromValue(arg.defaultValue, arg.type);\n  let argDecl = arg.name + ': ' + String(arg.type);\n\n  if (defaultAST) {\n    argDecl += ` = ${print(defaultAST)}`;\n  }\n\n  return argDecl + printDeprecated(arg.deprecationReason);\n}\n\nfunction printDirective(directive) {\n  return (\n    printDescription(directive) +\n    'directive @' +\n    directive.name +\n    printArgs(directive.args) +\n    (directive.isRepeatable ? ' repeatable' : '') +\n    ' on ' +\n    directive.locations.join(' | ')\n  );\n}\n\nfunction printDeprecated(reason) {\n  if (reason == null) {\n    return '';\n  }\n\n  if (reason !== DEFAULT_DEPRECATION_REASON) {\n    const astValue = print({\n      kind: Kind.STRING,\n      value: reason,\n    });\n    return ` @deprecated(reason: ${astValue})`;\n  }\n\n  return ' @deprecated';\n}\n\nfunction printSpecifiedByURL(scalar) {\n  if (scalar.specifiedByURL == null) {\n    return '';\n  }\n\n  const astValue = print({\n    kind: Kind.STRING,\n    value: scalar.specifiedByURL,\n  });\n  return ` @specifiedBy(url: ${astValue})`;\n}\n\nfunction printDescription(def, indentation = '', firstInBlock = true) {\n  const { description } = def;\n\n  if (description == null) {\n    return '';\n  }\n\n  const blockString = print({\n    kind: Kind.STRING,\n    value: description,\n    block: isPrintableAsBlockString(description),\n  });\n  const prefix =\n    indentation && !firstInBlock ? '\\n' + indentation : indentation;\n  return prefix + blockString.replace(/\\n/g, '\\n' + indentation) + '\\n';\n}\n"]},"metadata":{},"sourceType":"module"}